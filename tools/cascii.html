<!--
© Copyright 2025 Caspar Wylie <casparwylie@gmail.com>

 ██████╗ █████╗ ███████╗ ██████╗██╗██╗
██╔════╝██╔══██╗██╔════╝██╔════╝██║██║
██║     ███████║███████╗██║     ██║██║
██║     ██╔══██║╚════██║██║     ██║██║
╚██████╗██║  ██║███████║╚██████╗██║██║
 ╚═════╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝╚═╝

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<head>
  <title>CASCII</title>
  <meta name="title" content="Cascii: A web-based ASCII diagram builder" />
  <meta charset="UTF-8" />
  <meta name="description" content="A free, open-source ASCII diagram builder written in vanilla Javascript" />
  <meta name="keywords" content="Cascii, CASCII, ASCII, ascii, unicode, diagrams, drawing" />
  <meta name="author" content="Caspar Wylie" />
  <script>
    const VERSION = "v1.0.4";

    var layerManager;
    var eventManager;
    var externalHookManager;
    var areaSelectManager;
    var modeMaster;
    var charManager;
    var themeManager;
    var bodyComponent;

    var canvas;

    const ArrowKeyGroup = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    const firstVisit = !localStorage.getItem("visited");

    //////////////////
    ////// UTILS /////
    //////////////////

    function getClipboardText(limit) {
      let clipboardData = event.clipboardData || window.clipboardData;
      return clipboardData.getData("Text").substring(0, limit);
    }

    function isTablet() {
      return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    }

    function mobilePage() {
      let helpContent = new HelpComponent().value;
      document.body.innerHTML = `
        <h4 style='font-family:monospace' align='center'>
          <img src="https://i.postimg.cc/FzK68HLQ/cascii-logo.png" width="150"><br><br>
          Desktop only - Please see the <a href="https://github.com/casparwylie/cascii-core">GitHub</a> page!
        ${helpContent}
        </h4>
      `;
    }

    function reportError(message) {
      console.log(message);
    }

    function debugError(message) {
      console.trace();
      console.log(`[DEBUG]: ${message}`);
    }

    function roundHalf(value) {
      return parseInt(Math.round(value));
    }

    function roundUp(value) {
      return parseInt(Math.ceil(value));
    }

    function roundDown(value) {
      return parseInt(Math.floor(value));
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function sum(arr) {
      return arr.reduce((a, b) => a + b, 0);
    }

    function keyGroup(...names) {
      return names.join(",");
    }

    ///////////////////
    ////// THEMES /////
    ///////////////////
    class Theme {
      static Color = {
        blue: "#0394fc",
        darkBlue: "#0069b5",
        darkestBlue: "#1a3540",
        lightestBlue: "#baebff",
        lightRed: "#ff9494",
        red: "#f52f2c",
        darkRed: "#9e1910",
        darkestRed: "#381111",
        black: "black",
        white: "white",
        none: "transparent",
        pink: "#ff78db",
        green: "#49d65c",
        darkGreen: "#11381b",
        lightGreen: "#bdffdb",
        grey: "#525252",
        nearWhite: "#dedede",
        nearBlack: "#1c1c1c",
        nearGreenBlack: "#1a261a",
      };

      config = {
        bodyFgColor: Theme.Color.none,
        bodyBgColor: Theme.Color.none,
        bodyFont: "monospace",

        buttonBgColor: Theme.Color.black,
        buttonFgColor: Theme.Color.white,
        buttonBorderColor: Theme.Color.black,
        buttonSelectedBgColor: Theme.Color.blue,
        buttonClickBgColor: Theme.Color.blue,

        canvasBgColor: Theme.Color.none,

        pixelNormalBgColor: Theme.Color.none,
        pixelNormalFgColor: Theme.Color.white,
        pixelSelectedBgColor: Theme.Color.none,
        pixelSelectedFgColor: Theme.Color.darkBlue,
        pixelResizeBgColor: Theme.Color.red,
        pixelJointBgColor: Theme.Color.pink,
        pixelJointNearBgColor: Theme.Color.green,
        pixelCursorColor: Theme.Color.red,

        areaSelectionBgColor: Theme.Color.blue,

        informerDefaultBgColor: Theme.Color.blue,
        informerGoodBgColor: Theme.Color.green,
        informerBadBgColor: Theme.Color.red,

        informerDefaultFgColor: Theme.Color.black,
        informerGoodFgColor: Theme.Color.black,
        informerBadFgColor: Theme.Color.black,

        canvasFont: "monospace",

        warningRed: Theme.Color.red,

        gridColor: Theme.Color.none,
      };

      constructor(config) {
        for (let key in config) {
          this.config[key] = config[key];
        }
      }
    }

    class ThemeManager {
      defaultTheme = localStorage.getItem("theme") || "systemTheme";

      themes = {
        darkTheme: new Theme({
          bodyBgColor: Theme.Color.black,
          bodyFgColor: Theme.Color.white,
          buttonBgColor: Theme.Color.black,
          buttonFgColor: Theme.Color.white,
          buttonBorderColor: Theme.Color.grey,

          pixelCursorColor: Theme.Color.white,
          pixelNormalFgColor: Theme.Color.white,
          pixelResizeBgColor: Theme.Color.blue,
          pixelJointNearBgColor: Theme.Color.pink,
          pixelJointBgColor: Theme.Color.green,
          areaSelectionBgColor: Theme.Color.darkestBlue,
          gridColor: Theme.Color.nearBlack,
        }),
        lightTheme: new Theme({
          bodyBgColor: Theme.Color.white,
          bodyFgColor: Theme.Color.black,
          buttonBgColor: Theme.Color.white,
          buttonFgColor: Theme.Color.black,
          buttonBorderColor: Theme.Color.black,

          pixelCursorColor: Theme.Color.black,
          pixelNormalFgColor: Theme.Color.black,
          pixelResizeBgColor: Theme.Color.blue,
          pixelJointNearBgColor: Theme.Color.pink,
          pixelJointBgColor: Theme.Color.green,
          areaSelectionBgColor: Theme.Color.lightestBlue,
          gridColor: Theme.Color.nearWhite,
        }),
        consoleTheme: new Theme({
          bodyBgColor: Theme.Color.black,
          bodyFgColor: Theme.Color.green,
          buttonBgColor: Theme.Color.black,
          buttonFgColor: Theme.Color.green,
          buttonBorderColor: Theme.Color.green,
          buttonSelectedBgColor: Theme.Color.darkRed,

          pixelSelectedFgColor: Theme.Color.lightGreen,
          pixelResizeBgColor: Theme.Color.lightGreen,
          pixelCursorColor: Theme.Color.green,
          pixelNormalFgColor: Theme.Color.green,
          pixelJointNearBgColor: Theme.Color.lightGreen,
          pixelJointBgColor: Theme.Color.red,

          areaSelectionBgColor: Theme.Color.darkRed,
          gridColor: Theme.Color.nearGreenBlack,
        }),
      };

      constructor() {
        this.setTheme(this.defaultTheme);
      }

      getTheme() {
        return this.currentTheme.config;
      }

      static getPreferredSystemTheme() {
        return matchMedia("(prefers-color-scheme: light)").matches ? "lightTheme" : "darkTheme";
      }

      setTheme(theme) {
        localStorage.setItem("theme", theme);

        if (theme === "systemTheme") {
          theme = ThemeManager.getPreferredSystemTheme();
        }

        this.currentTheme = this.themes[theme];
      }

      renderTheme() {
        layerManager.refresh(() => bodyComponent.renderTheme());
      }
    }

    //////////////////
    ////// MODES /////
    //////////////////

    class ModeMaster {
      constructor() {
        this.callbacks = [];
        this._modes = [];
        this.setDefault();
      }

      registerCallback(func) {
        this.callbacks.push(func);
      }

      setDefault() {
        if (!this.hasAny()) this.reset("select");
      }

      modeChangedCallback() {
        for (var func of this.callbacks) func();
      }

      makeFunc(instruction) {
        // This just gives dispatchers a prettier notation, and
        // restricts us from getting carried away with complicated mode conditions.
        // If a condition can't be described by this notation, there's probably a cleaner
        // implementation (e.g introducing another mode or making custom method on the ModeMaster).

        // () => modeMaster.has("x", "y") becomes [modeMaster.has, "x", "y"]
        return instruction.length ? instruction[0].bind(this, ...instruction.slice(1)) : () => true;
      }

      change(beforeMode, afterMode) {
        let index = this._modes.indexOf(beforeMode);
        if (index == -1) return;
        this._modes[index] = afterMode;
        this.modeChangedCallback();
      }

      toggle(mode) {
        this.has(mode) ? this.remove(mode) : this.add(mode);
      }

      remove(...modes) {
        modes.forEach(mode => {
          let index = this._modes.indexOf(mode);
          if (index == -1) return;
          this._modes.splice(index, 1);
        });
        this.modeChangedCallback();
      }

      reset(...modes) {
        this._modes = modes;
        this.modeChangedCallback();
      }

      add(...modes) {
        modes = modes.filter(mode => !this.has(mode));
        this._modes = this._modes.concat(modes);
        this.modeChangedCallback();
      }

      has(...modes) {
        return modes.map(mode => this._modes.includes(mode)).every(Boolean);
      }

      hasAny() {
        // This is useful to determine if Cascii itself is active (any modes are on).
        // E.g if not, we shouldn't prevent default browser events by capturing ctrl commands.
        return this._modes.length > 0;
      }

      hasOr(...modes) {
        return modes.map(mode => this._modes.includes(mode)).some(Boolean);
      }

      is(...modes) {
        return this._modes.toString() == modes.toString();
      }

      isDrawyMode(layerMode) {
        // Returns for any draw-related mode (for a given layer).
        return this.hasOr("draw", "drawing", "writing") && this.has(layerMode);
      }

      removeLayerModes() {
        layerManager.getLayerTypes().forEach(name => this.remove(name));
        this.remove("line");
        this.remove("line-based");
      }

      getLayerType() {
        for (let type of layerManager.getLayerTypes()) {
          if (this.has(type)) return type;
        }
      }

      setSelectedLayerMode(layer) {
        this.removeLayerModes();
        this.add(layer.getType());

        // Rules for dynamic layer modes
        if (layer.isLine()) this.add("line");
        if (layer.isLineBased()) this.add("line-based");
      }
    }

    ////////////////
    //// EVENTS ////
    ////////////////
    class BaseExternalHookManager {
      /*
      This class should be overridden by optional dependencies
      allowing upstream functionality for specific hooks coming from this core app.

      E.g It is used to trigger server hooks for the server layer which,
      by design, is optionally attached.

      I want this file to open as an index.html and work out-of-the box,
      with 0 dependencies on a server, packaging, etc.
      */

      async getShortKeyUrl() {
        // Without a server, we return an empty short key.
        return "";
      }

      triggerDrawingChanged() {}
    }

    class EventDef {
      constructor(modeCondition, modeUpdate, callback = () => {}) {
        this.callback = callback;
        this.condition = modeMaster.makeFunc(modeCondition);
        this.update = modeMaster.makeFunc(modeUpdate);
      }

      run(event) {
        if (this.condition()) {
          this.update();
          this.callback(event);
          return true;
        }
      }
    }

    class EventManager {
      MAP = {
        document: {
          keyEvents: {
            keypress: {
              "*": [new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.keyDownEvent)],
            },
            keydown: {
              [keyGroup(...ArrowKeyGroup)]: [
                new EventDef([modeMaster.has, "selected"], [], event =>
                  layerManager.selectedArrowKeyDownEvent(event.key)
                ),
              ],
              [["Shift"]]: [new EventDef([modeMaster.hasAny], [modeMaster.add, "shift"])],
              [keyGroup("Backspace", "Delete")]: [
                new EventDef([modeMaster.has, "selected"], [modeMaster.reset, "select"], () =>
                  layerManager.deleteLayersEvent()
                ),
              ],
              [keyGroup("Escape")]: [
                new EventDef([modeMaster.hasOr, "writing", "selected"], [modeMaster.reset, "select"], () =>
                  layerManager.unselectAll()
                ),
              ],
              [keyGroup("Backspace", "Delete", ...ArrowKeyGroup)]: [
                new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.keyDownEvent),
              ],
              [keyGroup("Control")]: [new EventDef([modeMaster.hasAny], [modeMaster.add, "ctrl"])],
              [keyGroup("Z", "z")]: [
                new EventDef([modeMaster.has, "shift", "ctrl"], [], event => layerManager.redoEvent(event)),
              ],
              [keyGroup("z")]: [new EventDef([modeMaster.has, "ctrl"], [], event => layerManager.undoEvent(event))],
              [keyGroup("c")]: [
                new EventDef([modeMaster.has, "ctrl", "selected"], [], () => layerManager.copySelectedLayersEvent()),
              ],
              [keyGroup("a")]: [
                new EventDef([modeMaster.has, "ctrl"], [modeMaster.reset, "selected"], event =>
                  layerManager.selectAllEvent(event)
                ),
              ],
              [keyGroup("g")]: [
                new EventDef([modeMaster.has, "selected"], [], () => layerManager.groupSelectedLayersEvent()),
              ],
            },
            keyup: {
              [keyGroup("Shift")]: [new EventDef([modeMaster.has, "shift"], [modeMaster.remove, "shift"])],
              [keyGroup("Control")]: [new EventDef([modeMaster.has, "ctrl"], [modeMaster.remove, "ctrl"])],
            },
          },
        },

        window: {
          mouseEvents: {
            resize: [new EventDef([], [], event => canvas.scale())],
            paste: [
              new EventDef([modeMaster.has, "writing", "text"], [], event => layerManager.pasteToTextLayerEvent(event)),
              new EventDef([modeMaster.hasAny], [], event => layerManager.pasteAsTextLayerEvent(event)),
            ],
            // A mouseup should be detected beyond the canvas, so it's here instead.
            mouseup: [
              new EventDef([modeMaster.has, "drawing"], [modeMaster.change, "drawing", "draw"], event =>
                layerManager.changeEvent(event)
              ),
              new EventDef([modeMaster.has, "erasing"], [modeMaster.change, "erasing", "erase"]),
              new EventDef([modeMaster.has, "moving"], [modeMaster.remove, "moving"], event =>
                layerManager.changeEvent(event)
              ),
              new EventDef([modeMaster.has, "area-selecting"], [modeMaster.remove, "area-selecting"], event =>
                areaSelectManager.areaSelectingMouseUpEvent(event)
              ),
              new EventDef([modeMaster.has, "resizing"], [modeMaster.remove, "resizing"], event =>
                layerManager.changeEvent(event)
              ),
            ],
          },
        },

        canvas: {
          mouseEvents: {
            mousedown: [
              new EventDef(
                [modeMaster.has, "draw", "text"],
                [modeMaster.change, "draw", "writing"],
                TextLayer.drawMouseDownEvent
              ),
              new EventDef([modeMaster.has, "draw"], [modeMaster.change, "draw", "drawing"], Layer.drawMouseDownEvent),
              new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.writingMouseDownEvent),
              new EventDef([modeMaster.has, "erase"], [modeMaster.change, "erase", "erasing"], event =>
                layerManager.erasePixelEvent(event)
              ),
              new EventDef([modeMaster.hasOr, "selected", "select"], [], Layer.selectMouseDownEvent),
            ],

            mouseover: [
              new EventDef(
                [modeMaster.has, "draw", "line"], // Technically this should be for any joiner layer...
                [],
                BaseLineLayer.drawMouseOver
              ),
              new EventDef([modeMaster.has, "draw"], [], Layer.drawMouseOver),
              new EventDef([modeMaster.has, "drawing"], [], Layer.drawingMouseOverEvent),
              new EventDef([modeMaster.has, "erasing"], [], event => layerManager.erasePixelEvent(event)),
              new EventDef([modeMaster.has, "area-selecting"], [], event =>
                areaSelectManager.areaSelectingMouseOverEvent(event)
              ),
              new EventDef([modeMaster.has, "moving"], [], event => layerManager.movingMouseOverEvent(event)),
              new EventDef([modeMaster.has, "resizing"], [], event => layerManager.resizingMouseOverEvent(event)),
              new EventDef([modeMaster.hasOr, "selected", "select"], [], event =>
                layerManager.selectMouseOverEvent(event)
              ),
            ],

            dblclick: [
              new EventDef(
                [modeMaster.has, "selected", "text"],
                [modeMaster.change, "selected", "writing"],
                TextLayer.selectedDoubleClickEvent
              ),
              new EventDef([modeMaster.has, "writing"], [], TextLayer.selectedDoubleClickEvent),
            ],
          },
        },
      };

      assignMouseEventDefs(element, allDefs) {
        for (const [eventType, defs] of Object.entries(allDefs)) {
          element.addEventListener(eventType, event => {
            for (var def of defs) if (def.run(event)) return;
          });
        }
      }

      assignKeyEventDefs(element, defs) {
        Object.keys(defs).forEach(eventType => {
          element.addEventListener(eventType, event => {
            // This maps apple Command key to Ctrl.
            var eventKey = event.key == "Meta" ? "Control" : event.key;
            for (var keys in defs[eventType]) {
              for (let key of keys.split(",")) {
                if (key == eventKey || key == "*") {
                  for (var def of defs[eventType][keys]) {
                    if (def.run(event)) return;
                  }
                }
              }
            }
          });
        });
      }

      assignAll(namedElements) {
        for (const [elementName, eventGroups] of Object.entries(this.MAP)) {
          for (const [eventGroup, eventDefs] of Object.entries(eventGroups)) {
            switch (eventGroup) {
              case "mouseEvents":
                this.assignMouseEventDefs(namedElements[elementName], eventDefs);
                break;
              case "keyEvents":
                this.assignKeyEventDefs(namedElements[elementName], eventDefs);
                break;
            }
          }
        }
      }
    }

    ///////////////
    //// CHARS ////
    ///////////////

    class CharManager {
      // Useful: https://www.w3.org/TR/xml-entity-names/025.html
      // And: https://www.amp-what.com/unicode/search/dot
      charset = {
        // Dotted lines
        "•": ["dotted", "line", "vertical", "lateral", "corner", "generic", "unicode"],
        ".": ["dotted", "line", "vertical", "lateral", "corner", "generic", "ascii"],

        // Solid lines
        "━": ["solid-bold", "line", "lateral", "unicode"],
        "┃": ["solid-bold", "line", "vertical", "unicode"],
        "|": ["solid-thin", "solid-bold", "line", "vertical", "ascii"],
        "─": ["solid-thin", "line", "lateral", "unicode"],
        "│": ["solid-thin", "line", "vertical", "unicode"],
        "\\": ["solid-thin", "solid-bold", "diag-back", "line", "unicode", "ascii"],
        "/": ["solid-thin", "solid-bold", "diag-forward", "line", "unicode", "ascii"],

        // Dashed lines
        "'": ["dashed", "line", "vertical", "ascii"],
        "╶": ["dashed", "line", "lateral", "unicode"],
        "╷": ["dashed", "line", "vertical", "unicode"],
        "-": ["dashed", "solid-bold", "solid-thin", "line", "lateral", "ascii"],

        // Arrows
        "^": ["arrow", "up", "ascii"],
        ">": ["arrow", "right", "ascii"],
        "<": ["arrow", "left", "ascii"],
        v: ["arrow", "down", "ascii"],
        "▲": ["arrow", "up", "unicode"],
        "▶": ["arrow", "right", "unicode"],
        "◀": ["arrow", "left", "unicode"],
        "▼": ["arrow", "down", "unicode"],

        // Corners
        "┏": ["corner", "solid-bold", "top-left", "unicode"],
        "┓": ["corner", "solid-bold", "top-right", "unicode"],
        "┗": ["corner", "solid-bold", "bottom-left", "unicode"],
        "┛": ["corner", "solid-bold", "bottom-right", "unicode"],

        "┌": ["corner", "dashed", "solid-thin", "top-left", "unicode"],
        "┐": ["corner", "dashed", "solid-thin", "top-right", "unicode"],
        "└": ["corner", "dashed", "solid-thin", "bottom-left", "unicode"],
        "┘": ["corner", "dashed", "solid-thin", "bottom-right", "unicode"],

        "·": ["diamond-corner", "solid-thin", "solid-bold", "vertical", "lateral", "unicode"],

        "+": [
          "corner",
          "diamond-corner",
          "lateral",
          "vertical",
          "solid-bold",
          "solid-thin",
          "dashed",
          "ascii",
          "top-left",
          "top-right",
          "bottom-left",
          "bottom-right",
          "generic",
        ],

        // Misc
        x: ["free"],
      };

      constructor() {
        this.charsetForm = localStorage.getItem("charset") || "unicode"; // Default to unicode
      }

      getBestChar(...description) {
        var lastMatches = -1;
        var lastChar = null;
        for (let character in this.charset) {
          let tags = this.charset[character];
          let matches = tags.filter(tag => description.includes(tag)).length;
          if (matches > lastMatches) {
            lastMatches = matches;
            lastChar = character;
          }
        }
        return lastChar;
      }

      getCharset() {
        return this.charsetForm;
      }

      setCharset(form) {
        localStorage.setItem("charset", form);
        this.charsetForm = form;
      }

      getDiagBackLine(lineForm) {
        return this.getBestChar("diag-back", "line", lineForm, this.getCharset());
      }

      getDiagForwardLine(lineForm) {
        return this.getBestChar("diag-forward", "line", lineForm, this.getCharset());
      }

      getVerticalLine(lineForm) {
        return this.getBestChar("vertical", "line", lineForm, this.getCharset());
      }

      getLateralLine(lineForm) {
        return this.getBestChar("lateral", "line", lineForm, this.getCharset());
      }

      getCorner(lineForm, position) {
        return this.getBestChar("corner", position, lineForm, this.getCharset());
      }

      getDiamondCorner(lineForm, position) {
        return this.getBestChar("diamond-corner", position, lineForm, this.getCharset());
      }

      getArrow(direction) {
        return this.getBestChar("arrow", direction, this.getCharset());
      }

      getFree() {
        return this.getBestChar("free");
      }
    }

    //////////////
    //// CORE ////
    //////////////

    class GroupManager {
      constructor() {
        this.layerGroups = [];
        this.layerGroupHistory = [[]];
      }

      empty() {
        this.layerGroups = [];
        this.layerGroupHistory = [];
      }

      capture() {
        this.layerGroupHistory.unshift(structuredClone(this.layerGroups));
      }

      jumpHistory(cursor) {
        this.layerGroups = this.layerGroupHistory[cursor] || [];
      }

      findGroupsFromLayers(layers) {
        /*
        Find groups which are fully included in the provided layers.
        E.g
        Groups = [[1, 2, 3], [5, 6], [4, 5], [1, 2]]
        layers = [1, 2, 3, 4]
          => [[1, 2, 3], [1, 2]]
        */

        // This means, somehow, we are looking for groups with layers
        // that have been removed.
        if (!layers.every(Boolean)) return [];

        var foundGroups = [];
        let layerIds = layers.map(layer => layer.id);
        for (var groupLayerIds of this.layerGroups) {
          if (groupLayerIds.map(layerId => layerIds.includes(layerId)).every(Boolean)) {
            foundGroups.push(groupLayerIds);
          }
        }
        return foundGroups;
      }

      ungroupLayers(layers) {
        let groups = this.findGroupsFromLayers(layers).map(group => group.toString());
        this.layerGroups = this.layerGroups.filter(group => !groups.includes(group.toString()));
      }

      groupLayers(layers) {
        this.layerGroups.push(layers.map(layer => layer.id));
      }

      getSiblingLayerIds(memberLayer) {
        var layerIds = [];
        for (var group of this.layerGroups) {
          if (group.includes(memberLayer.id)) layerIds = layerIds.concat(group);
        }
        return layerIds;
      }

      tidy(layers) {
        var index = 0;
        for (var layerGroup of this.layerGroups) {
          this.layerGroups[index] = layerGroup.filter(layerId => !layers.includes(layerId));
          index++;
        }
        // Tidy empty / one layer groups
        this.layerGroups = this.layerGroups.filter(group => group.length > 1);
      }
    }

    class AreaSelectManager {
      constructor() {
        this.areaSelectionPixels = [];
      }

      clearAreaSelection() {
        this.areaSelectionPixels.forEach(pixel => pixel.renderNormal());
        this.areaSelectionPixels = [];
      }

      areaSelectingMouseUpEvent(event) {
        this.clearAreaSelection();
        // Re-render selected layers having just cleared pixels.
        layerManager.getSelectedLayers().forEach(layer => layer.renderSelected());
      }

      areaSelectingMouseOverEvent(event) {
        this.clearAreaSelection();
        let firstPixel = layerManager.getSelectPixel();

        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let lateralDiff = activePixel.col - firstPixel.col;
        let verticalDiff = activePixel.row - firstPixel.row;
        let total = Math.abs(lateralDiff * verticalDiff);

        var drawRow = firstPixel.row;
        var drawCol = firstPixel.col;
        for (var row = 0; row <= Math.abs(verticalDiff); row++) {
          for (var col = 0; col <= Math.abs(lateralDiff); col++) {
            let pixel = canvas.getPixelByRowCol(parseInt(drawRow), parseInt(drawCol));
            this.areaSelectionPixels.push(pixel);
            drawCol += lateralDiff / Math.abs(lateralDiff);
          }
          drawRow += verticalDiff / Math.abs(verticalDiff);
          drawCol = firstPixel.col;
        }

        this.selectLayersInAreaSelection();
        this.areaSelectionPixels.forEach(pixel => pixel.renderAreaSelected());
      }

      selectLayersInAreaSelection() {
        let layersToSelect = [];
        for (var layer of layerManager.layers) {
          let layerPixelIds = layer.pixels.map(pixel => pixel.id());
          let selectedPixelIds = this.areaSelectionPixels.map(pixel => pixel.id());
          if (layerPixelIds.filter(pixel => !selectedPixelIds.includes(pixel)).length) {
            if (layer.isSelected()) layer.unselect();
          } else {
            layersToSelect.push(layer);
          }
        }
        if (layersToSelect.length) modeMaster.change("select", "selected");
        for (let layer of layersToSelect) {
          layer.select();
          layerManager.selectGroupsByMemberLayer(layer);
        }
      }
    }

    class LayerManager {
      LayerRegister = [
        FreeLineLayer,
        FreeLayer,
        StepLineLayer,
        CircleLayer,
        SwitchLineLayer,
        SquareLayer,
        TextLayer,
        TableLayer,
        DiamondLayer,
      ];

      constructor() {
        this.layers = [];
        this.selectedPixel = null;
        this.layerHistory = [[]];
        this.historyCursor = 0;
        this.editingTextLayer = null;
        this.groupManager = new GroupManager();
      }

      getLayerTypes() {
        return this.LayerRegister.map(cls => cls.type);
      }

      getLineBasedLayerTypes() {
        return this.LayerRegister.filter(cls => cls.lineBased).map(cls => cls.type);
      }

      getLayerClassByType(type) {
        for (let cls of this.LayerRegister) if (type == cls.type) return cls;
      }

      add(layer) {
        this.layers.unshift(layer);
      }

      addSecond(layer) {
        this.layers.splice(1, 0, layer);
      }

      getLatestLayer() {
        return this.layers[0];
      }

      hasLayer(layerId) {
        return this.layers.map(layer => layer.id).includes(layerId);
      }

      getLayerById(layerId) {
        for (var layer of this.layers) {
          if (layer.id == layerId) return layer;
        }
      }

      getLayerByPixelId(id) {
        // Descending (reversed)
        for (var layer of this.getLayersOrderedByZindex().reverse()) {
          if (layer.hasPixel(id)) return layer;
        }
      }

      setLayers(layers) {
        this.layers = layers;
      }

      encodeAll() {
        let encodedLayers = this.layers.map(layer => layer.encode());
        let data = {
          layers: encodedLayers,
          groups: this.groupManager.layerGroups || [],
        };
        return JSON.stringify(data);
      }

      decodeLayers(layers) {
        return layers.map(layer => this.getLayerClassByType(layer.ty).decode(layer));
      }

      import(encodedData) {
        let data = JSON.parse(encodedData);
        this.refresh(() => this.empty());
        this.setLayers(this.decodeLayers(data.layers));
        this.groupManager.layerGroups = data.groups || [];

        // We don't encode pixel data, so until we redraw, layers are empty
        this.redrawAll();

        // Ensure the newly imported data is aligned with local storage
        this.saveToLocalStorage();

        // Capture the latest state
        this.capture();
        return true;
      }

      importFromLocalStorage() {
        let data = localStorage.getItem("savedDrawing");
        if (data && JSON.parse(data).layers.length) this.import(data);
      }

      saveToLocalStorage() {
        localStorage.setItem("savedDrawing", this.encodeAll());
      }

      redrawAll() {
        // Why do we redraw twice? Because only once everything
        // is drawn, can the correct draw be fully determined.
        // For example, step line flipping needs to inspect other layers,
        // which can only be done once all drawn.
        this.refresh(() => {
          this.layers.forEach(layer => layer.redraw());
          this.layers.forEach(layer => layer.redraw());
        });
      }

      getSelectedLayers() {
        return this.layers.filter(layer => layer.isSelected());
      }

      deleteSelectedLayers() {
        this.getSelectedLayers().forEach(layer => layer.empty());
        this.triggerChanged();
      }

      selectGroupsByMemberLayer(memberLayer) {
        let siblingLayerIds = this.groupManager.getSiblingLayerIds(memberLayer);
        siblingLayerIds.forEach(layerId => this.getLayerById(layerId).select());
      }

      undo() {
        let limit = this.layerHistory.length - 1;
        this.historyCursor = this.historyCursor < limit ? this.historyCursor + 1 : limit;
        this.jumpHistory();
      }

      redo() {
        this.historyCursor = this.historyCursor > 0 ? this.historyCursor - 1 : 0;
        this.jumpHistory();
      }

      jumpHistory() {
        // Copy historic layers to avoid mutating them now that they're current.
        // The past version will otherwise mutate with the present...
        this.setLayers(this.copyLayersIdentically(this.layerHistory[this.historyCursor]));
        this.groupManager.jumpHistory(this.historyCursor);

        // Put latest visuals to local storage (we can't rely on capture as redo should not capture).
        this.saveToLocalStorage();

        // We also trigger a change directly as to not capture.
        externalHookManager.triggerDrawingChanged();

        // Unset this as changing history makes this out of date, and
        // tracking it is a bit overkill (a user can just re-select the layer after an undo)
        this.editingTextLayer = null;
      }

      copyLayersIdentically(layers) {
        return layers.map(layer => layer.copy(true));
      }

      copyAndRenderSelectedLayers() {
        // Copy layers and create a lookup for old to new. This can be used
        // by various functions to update new layers with appropriate relationships
        // and states (given those of old layers).
        let layerLookup = {};
        let layersToCopy = this.getSelectedLayers();
        for (var layer of layersToCopy) layerLookup[layer.id] = { old: layer, new: layer.copyAndRender() };
        this.moveLayersToAvailableSpace(Object.values(layerLookup).map(oldNewLayer => oldNewLayer.new));

        this.repointJointsForCopiedLayers(layerLookup);
        this.regroupForCopiedLayers(layerLookup);
        this.repointTableTextLayers(layerLookup);

        this.triggerChanged();
      }

      repointTableTextLayers(layerLookup) {
        // For tables, we must point text layer references to the newly copied text layers.
        // We also ensure new TextLayers point to their new table.
        for (let oldLayerId in layerLookup) {
          let oldLayer = layerLookup[oldLayerId].old;
          let newLayer = layerLookup[oldLayerId].new;
          if (oldLayer.is("table")) {
            for (let cellId in oldLayer.textLayers) {
              let oldTextLayerId = oldLayer.textLayers[cellId];

              // Find the new version of the TextLayer given the old TextLayer ID.
              let newTextLayer = layerLookup[oldTextLayerId].new;

              // Give the new TextLayer it's new table reference.
              newTextLayer.tableId = newLayer.id;

              // Give the TableLayer at the corresponding cell it's new TextLayer reference.
              newLayer.textLayers[cellId] = newTextLayer.id;
            }
          }
        }
      }

      regroupForCopiedLayers(layerLookup) {
        // This groups the newly copied layers which were grouped before being copied.
        let layersToCopy = Object.values(layerLookup).map(oldNewLayer => oldNewLayer.old);
        let groupsToCopy = this.groupManager.findGroupsFromLayers(layersToCopy);
        for (var group of groupsToCopy) {
          var newGroup = group.map(layerId => layerLookup[layerId].new);
          this.groupManager.groupLayers(newGroup);
        }
        this.capture();
      }

      repointJointsForCopiedLayers(layerLookup) {
        // This goes through joints of old layers and updates
        // the joint layers to the newly copied joints if they
        // were included in the copied selection / are in the lookup.
        for (var oldLayerId in layerLookup) {
          let oldNewLayer = layerLookup[oldLayerId];
          for (var joint of oldNewLayer.old.joints) {
            // Find the new version of the joint layer given the old layer ID.
            let jointOldNewLayer = layerLookup[joint.layerId];

            if (jointOldNewLayer) {
              let newJoint = structuredClone(joint);
              newJoint.layerId = jointOldNewLayer.new.id;
              oldNewLayer.new.joints.push(newJoint);
            }
          }
        }
      }

      getNearOverlappingCount(subjectLayer, withNames) {
        // This counts how many pixels from other layers are near
        // or overlapping the subjectLayer. withNames can also
        // be provided to only worry about specific layer.getType()s
        // being near/overlapping. This is mainly used to make decisions
        // based on how busy a space is.
        var count = 0;
        for (let layer of this.layers) {
          if (withNames && withNames.includes(layer.getType())) {
            count += layer.getNearOverlappingCount(subjectLayer);
          }
        }
        return count;
      }

      unselectAll() {
        this.layers.forEach(layer => layer.unselect());
        if (this.editingTextLayer) this.editingTextLayer.clearLastCursor();
      }

      switchModeCallback() {
        // This is used when a major mode is changed to clear up a few things.
        bodyComponent.hidePopups();
        this.unselectAll();
        this.capture();
      }

      refresh(updateFunc) {
        this.clearAll();
        updateFunc();
        this.renderAll();
      }

      tidyAllJoints(layersToDelete) {
        for (var layer of this.layers) {
          layer.joints = layer.joints.filter(joint => !layersToDelete.includes(joint.layerId));
          layer.tidyJoints();
        }
      }

      tidyLayers() {
        // Find layer IDs for dereferencing
        let layersToDelete = this.layers.filter(layer => !layer.pixels.length).map(layer => layer.id);

        // Delete empty layers
        this.setLayers(this.layers.filter(layer => !layersToDelete.includes(layer.id)));

        // Delete references to empty layers in groups
        this.groupManager.tidy(layersToDelete);

        // Delete references to empty layers in layer joints
        this.tidyAllJoints(layersToDelete);

        // Delete references to empty layers in tables (this really shouldn't be needed),
        // But a user could ungroup a table manually and delete layers.
        this.tidyAllTables(layersToDelete);
      }

      tidyAllTables(layersToDelete) {
        for (let layer of this.layers.filter(layer => layer.is("table"))) {
          for (let key in layer.textLayers) {
            if (layersToDelete.includes(layer.textLayers[key])) delete layer.textLayers[key];
          }
        }
      }

      clearAll() {
        this.layers.forEach(layer => layer.clear());
      }

      getLayersOrderedByZindex() {
        // Ascending
        return this.layers.slice().sort((a, b) => a.zindex - b.zindex);
      }

      renderAll() {
        this.getLayersOrderedByZindex().forEach(layer => layer.render());
      }

      layerPixelIsVisible(targetLayer, targetPixel) {
        // This checks if the value of a layer at a specific pixel is actually showing.
        // Otherwise, another layer using the same pixel is showing it's value in front.
        // Note, joint pixels make this method annoyingly complicated...

        // Descending
        for (let layer of this.getLayersOrderedByZindex().reverse()) {
          // If the pixel is either part of the layer, or used as a joint pixel by the layer.
          let isUsingPixel = layer.usesPixel(targetPixel.id());
          let isTargetLayer = layer.id == targetLayer.id;

          // We need to determine if layer and targetLayer are 'connected' at the target pixel,
          // regardless of if a joint has been created yet.
          let isConnectedToTargetLayer =
            layer.hasJoinerPixel(targetPixel.id()) || layer.hasJointPixel(targetPixel.id());
          // If the first layer to have the target pixel is the target layer, it's visible.
          // IsUsingPixel check here isn't really needed as targetLayer should always use targetPixel,
          // nonetheless it makes more sense in case the provided target layer/pixel is wrong.
          if (isTargetLayer && isUsingPixel) return true;

          // If the first layer to have the target pixel is another layer,
          // and that layer isn't connected to the target layer, it's not visible.
          // If they are connected, we don't want them to hide each other because:
          //  - Other layers may want to see and probe the joint pixel
          //    (joiner pixel should not hide the joint pixel).
          //  - A joint will never actually be possible.
          //    (joiner pixel should not hide the joint pixel, otherwise it'll never make a joint!).
          //  - Joint pixels aren't always on the layer, and are therefore 'transparent'
          //    (joint pixels alone shouldn't hide joiner pixels).
          if (!isTargetLayer && isUsingPixel && !isConnectedToTargetLayer) return false;
        }

        // There is no obvious case we should arrive here, unless the targetLayer somehow
        // doesn't use the targetPixel.
        return false;
      }

      empty() {
        this.setLayers([]);
        this.layerHistory = [];
        this.groupManager.empty();
      }

      emptyEvent() {
        this.empty();
        this.triggerChanged();
      }

      triggerChanged() {
        this.tidyLayers();
        this.capture();
        // We also save latest changes to local storage.
        this.saveToLocalStorage();
        // We also trigger an external hook as this is helpful knowledge.
        externalHookManager.triggerDrawingChanged();
      }

      capture() {
        // This is used to record history for undo/redo state.
        this.historyCursor = 0;
        this.layerHistory.unshift(this.copyLayersIdentically(this.layers));
        this.groupManager.capture();
      }

      setSelectPixel(selectedPixel) {
        this.selectedPixel = selectedPixel;
      }

      getSelectPixel() {
        return this.selectedPixel;
      }

      atomicCommit(...jobs) {
        let committedLayers = [];
        for (let [layer, func] of jobs) {
          let committed = layer.commit(() => func(layer));
          if (!committed) {
            // If a the layer failed to move, then rollback the others that did move.
            committedLayers.forEach(layer => layer.rollback());
            return;
          }
          committedLayers.push(layer);
        }
        return true;
      }

      moveLayersAtomically(layers, verticalDiff, lateralDiff) {
        // If multiple layers are selected, they should all move
        // together to avoid breaking joints. If one layer hits
        // the canvas boundary, none should move. Hence, here
        // we ensure all moves are doable before keeping them.
        let jobs = layers.map(layer => [layer, () => layer.move(verticalDiff, lateralDiff)]);
        let success = this.atomicCommit(...jobs);
        if (!success) return;

        // If we are here, all layers have moved, so we can now resize
        // their joiner layers.

        // resizeSelectedJoinerLayers is false here because moving
        // them takes priority, and doing both is error prone. They will move
        // with their joint layer anyway, meaning the joint is persisted.
        // Otherwise, the joiner layer could unjoin because it's moved
        // twice, from the main move routine and the resize joiner layer routine.
        for (let layer of layers) layer.resizeJoinerLayers(false);
        return true;
      }

      moveSelectedLayers(verticalDiff, lateralDiff) {
        let selectedLayers = this.getSelectedLayers();
        this.refresh(() => this.moveLayersAtomically(selectedLayers, verticalDiff, lateralDiff));
        this.findJoints(selectedLayers);
      }

      moveLayersToAvailableSpace(layers) {
        let directions = [
          [1, 1],
          [-1, 1],
          [1, -1],
          [-1, -1],
        ];
        for (let direction of directions) {
          if (this.moveLayersAtomically(layers, ...direction)) return true;
        }
        return false;
      }

      findJoints(changedLayers) {
        for (var layer of this.layers) {
          if (layer.isSelected()) continue;
          // Only joinable layers will return joint pixels here and therefore get probed.
          let keyedJoints = layer.getKeyedJointPixels();
          for (let jointKey in keyedJoints) {
            let jointPixel = keyedJoints[jointKey];
            var renderState = -1;
            for (var probingLayer of changedLayers) {
              if (probingLayer.id == layer.id) continue;
              // Only prober layers will look for joins (e.g lines).
              let state = probingLayer.probeJoint(layer, jointKey, jointPixel);
              if (state > renderState) renderState = state;
            }
            switch (renderState) {
              case 0:
                jointPixel.renderWasSelected();
                break;
              case 1:
                jointPixel.renderJointNear();
                break;
              case 2:
                jointPixel.renderJoint();
                break;
            }
          }
        }
      }

      getJoinersFromLayers(layers) {
        var layerIds = [];
        for (var layer of layers) {
          for (var joint of layer.joints) {
            layerIds.push(joint.layerId);
          }
        }
        return layerIds;
      }

      prepareLayerResizing(activePixel, leadLayer) {
        let resizePixelIndex = leadLayer.getResizePixelIndex(activePixel);
        if (resizePixelIndex == -1) return false;
        for (var resizeLayer of this.getSelectedLayers()) {
          if (!resizeLayer.isResizable()) continue;
          var resizePixel;
          if (resizeLayer.id == leadLayer.id) {
            // If the selected layer is the lead / currently selected layer
            // Then we already know the activePixel is the resize pixel.
            resizePixel = activePixel;
          } else if (resizeLayer.getType() == leadLayer.getType() && !leadLayer.isLine()) {
            // If the lead layer is the same type as a selected layer,
            // we can use the same resize pixel position and resize the layer
            // in the same way for the best experience.

            // Lines are excluded because resize positions are subjective to the line
            // depending on where it was drawn from. Using the "nearest" logic is better.
            resizePixel = resizeLayer.getResizePixels()[resizePixelIndex];
          } else {
            // Otherwise, we find the layer's nearest resize pixel and
            // resize from there.
            resizePixel = resizeLayer.getNearestResizePixel(activePixel);
          }
          // The "to" pixel has been determined above depending on various rules.
          resizeLayer.setToPixel(resizePixel);

          // The resize "from" pixel is the opposite to the active "to" resize pixel
          // determined above. We set it here as the from pixel to mimic
          // the act of drawing it from the first pixel selected.
          let fromResizePixel = resizeLayer.getResizeOppositePixel(resizePixel);
          resizeLayer.setFromPixel(fromResizePixel);
        }
        return true;
      }

      renderCharset() {
        for (let layer of this.layers) layer.redrawChars(layer.lineForm);
        this.triggerChanged();
      }

      // Generic multi-layer based events...

      resizingMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layers = this.getSelectedLayers();
        this.refresh(() => this.resizeLayers(layers, activePixel));
        this.findJoints(layers);
      }

      resizeLayers(layers, activePixel) {
        let selectPixel = this.getSelectPixel();
        let verticalDiff = activePixel.row - selectPixel.row;
        let lateralDiff = activePixel.col - selectPixel.col;
        let joinerLayers = this.getJoinersFromLayers(layers);

        for (var layer of layers) {
          // Selected layers that are joiners to another selected layer should not
          // get resized, as the joint will handle moving it correctly.
          // Otherwise, the resize is at risk of unexpectly unjoining the layers
          // in question.
          if (joinerLayers.includes(layer.id)) continue;

          // If the layer belongs to a table, resizing should never happen
          // as resizing tables is used to add/remove columns, not move child
          // layers around.
          if (layer.hasTable()) continue;
          if (!layer.isResizable()) {
            // If the layer is not resizable, the best thing we can do is move it.
            if (layer.commit(() => layer.move(verticalDiff, lateralDiff))) layer.resizeJoinerLayers(true);
            continue;
          }
          /*
          layer.fromPixel: The "from" pixel for a specific layer (where it should be drawn from)
          layer.toPixel: The pixel the layer should draw to
          selectPixel: The previous activePixel to determine the diff with current activePixel.
                       This pixel starts as wherever the user first pressed.
          activePixel: The actual current pixel of the mouse.

          layer.fromPixel
              ._________
              *        |
              |        |
              |        |       *.. selectedPixel
              |        |        \
              |        |         \ .. vertical/lateralDiff
              |________*          \
                       .\           * .. activePixel
                       . \
                       .  \
                       .   * .. layer.toPixel + vertical/lateralDiff
                       .
                    layer.toPixel

          With both of these determined, the layer can be resized.
          */

          // For this layer, the resize pixel is out of bounds.

          let toPixel = canvas.getPixelByRowCol(layer.toPixel.row + verticalDiff, layer.toPixel.col + lateralDiff);
          if (!toPixel) continue;

          // resizeSelectedJoinerLayers is true because layers are changing
          // and selected joiner layers should favour maintaining joints and resizing
          // that way, instead of resizing independently.
          layer.draw(toPixel, true);
        }
        // Note we set selectPixel to activePixel so that the next iteration
        // can diff the new activePixel to this one.
        this.setSelectPixel(activePixel);
      }

      movingMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let lastPixelSelected = this.getSelectPixel();
        let verticalDiff = activePixel.row - lastPixelSelected.row;
        let lateralDiff = activePixel.col - lastPixelSelected.col;
        this.moveSelectedLayers(verticalDiff, lateralDiff);
        this.setSelectPixel(activePixel);
      }

      selectedArrowKeyDownEvent(key) {
        var verticalDiff = 0;
        var lateralDiff = 0;
        switch (key) {
          case "ArrowUp":
            verticalDiff = -1;
            break;
          case "ArrowRight":
            lateralDiff = 1;
            break;
          case "ArrowDown":
            verticalDiff = 1;
            break;
          case "ArrowLeft":
            lateralDiff = -1;
            break;
        }
        this.moveSelectedLayers(verticalDiff, lateralDiff);
        this.triggerChanged();
      }

      deleteLayersEvent(event) {
        this.refresh(() => this.deleteSelectedLayers());
      }

      copySelectedLayersEvent(event) {
        this.refresh(() => this.copyAndRenderSelectedLayers());
      }

      changeEvent(event) {
        this.triggerChanged();
      }

      selectMouseOverEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layerOver = layerManager.getLayerByPixelId(event.target.id);
        layerOver ? canvas.setCursor("pointer") : canvas.setCursor("default");
        // Ascending
        for (let layer of this.getLayersOrderedByZindex()) {
          for (var resizePixel of layer.getResizePixels()) {
            if (
              (layer.isSelected() || activePixel.isNear(resizePixel)) &&
              this.layerPixelIsVisible(layer, resizePixel)
            ) {
              resizePixel.renderResizable();
            } else {
              resizePixel.renderWasSelected();
            }
          }
        }
      }

      undoEvent(event) {
        this.refresh(() => this.undo());
      }

      redoEvent(event) {
        this.refresh(() => this.redo());
      }

      groupSelectedLayersEvent(event) {
        this.groupManager.groupLayers(this.getSelectedLayers());
        bodyComponent.informerComponent.report("Successfully grouped", "good");
        this.triggerChanged();
      }

      ungroupSelectedLayersEvent(event) {
        this.groupManager.ungroupLayers(this.getSelectedLayers());
        layerManager.unselectAll();
        modeMaster.reset("select");
        bodyComponent.informerComponent.report("Successfully ungrouped", "good");
        this.triggerChanged();
      }

      redrawLinesEvent(direction) {
        for (var layer of this.getSelectedLayers()) {
          if (layer.isLine()) this.refresh(() => layer.toggleArrows(direction));
        }
        this.triggerChanged();
      }

      redrawLineBasedEvent(lineForm) {
        for (var layer of this.getSelectedLayers()) {
          if (layer.isLineBased()) this.refresh(() => layer.redrawChars(lineForm));
        }
        this.triggerChanged();
      }

      selectAllEvent(event) {
        event.preventDefault();
        this.layers.forEach(layer => layer.select());
      }

      erasePixelEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layer = this.getLayerByPixelId(activePixel.id());
        if (layer && !layer.is("free")) {
          bodyComponent.informerComponent.report("Can only erase free drawings!", "bad");
          return;
        }
        if (layer) this.refresh(() => layer.erasePixel(activePixel.id()));
        activePixel.clear();
      }

      getHighestZindex() {
        // This ensures the first ever layer is set to 0 given that
        // layers use this method during initialization to determine
        // the next zindex needed.
        // (Math.max() with nothing returns infinity... :/ )
        if (this.layers.length == 0) return 0;

        return Math.max(...this.getZindexes());
      }

      getZindexes() {
        return this.layers.map(layer => layer.zindex);
      }

      getLowestZindex() {
        return Math.min(...this.layers.map(layer => layer.zindex));
      }

      bringForwardEvent(event) {
        let highestZindex = this.getHighestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex++));
        this.triggerChanged();
      }

      sendBackwardsEvent(event) {
        let lowestZindex = this.getLowestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex--));
        this.triggerChanged();
      }

      bringToFrontEvent(event) {
        let highestZindex = this.getHighestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => (layer.zindex = highestZindex + 1)));
        this.triggerChanged();
      }

      sendToBackEvent(event) {
        let lowestZindex = this.getLowestZindex();
        this.refresh(() => this.getSelectedLayers().forEach(layer => (layer.zindex = lowestZindex - 1)));
        this.triggerChanged();
      }

      pasteToTextLayerEvent(event) {
        event.stopPropagation();
        event.preventDefault();
        let text = getClipboardText(100);
        this.refresh(() => {
          let commited = this.editingTextLayer.commit(() => this.editingTextLayer.paste(text));
          if (!commited) {
            bodyComponent.informerComponent.report("Cannot paste, content leaves canvas", "bad");
          }
        });
      }

      pasteAsTextLayerEvent(event) {
        event.stopPropagation();
        event.preventDefault();
        modeMaster.reset("select");
        let text = getClipboardText(1000);
        // Just put it in the middle
        let textLayer = new TextLayer(
          canvas.getPixelByRowCol(roundDown(canvas.rowCount / 2), roundDown(canvas.colCount / 2)).id()
        );
        textLayer.contents = text.split("");
        layerManager.add(textLayer);
        this.refresh(() => {
          if (textLayer.commit(() => textLayer.drawLayer())) {
            layerManager.triggerChanged();
            textLayer.select();
            return;
          }
          bodyComponent.informerComponent.report("Cannot paste, content leaves canvas", "bad");
        });
      }
    }

    ///////////////////
    ///// LAYERS //////
    ///////////////////

    class Layer {
      static type = "base";
      static lineBased = false;
      static line = false;

      getType() {
        return this.constructor.type;
      }

      isLineBased() {
        return this.constructor.lineBased;
      }

      isLine() {
        return this.constructor.line;
      }

      is(layerType) {
        return this.getType() == layerType;
      }

      constructor(firstPixelId) {
        this.lineForm = "solid-thin"; // Default
        this.id = this.makeId();
        this.pixels = [];
        this.values = [];
        this.joints = [];
        this.zindex = layerManager.getHighestZindex() + 1;
        this._isSelected = false;
        this.commitLock = false;
        this.setFromPixel(canvas.getPixelById(firstPixelId));
        this.setToPixel(null);
        this.stashed = {};
      }

      static decode(encodedLayer) {
        let layerClass = layerManager.getLayerClassByType(encodedLayer.ty);
        let layer = new layerClass(encodedLayer.fp);
        layer.id = encodedLayer.id;
        layer.setToPixel(canvas.getPixelById(encodedLayer.tp));
        layer.zindex = encodedLayer.zi;
        layer.lineForm = encodedLayer.lf;
        layer.joints = encodedLayer.jts;
        return layer;
      }

      encode() {
        return {
          ty: this.getType(),
          id: this.id,
          fp: this.fromPixel.id(),
          tp: this.toPixel.id(),
          zi: this.zindex,
          lf: this.lineForm,
          jts: this.joints,
        };
      }

      redrawChars(lineForm) {
        this.lineForm = lineForm;
        this.redraw();
      }

      makeId() {
        return randomInt(1, 10000000).toString();
      }

      static drawToSelectMouseDownEvent(event, selectedLayer) {
        // Just a little side hustle to auto-switch to selecting
        // if drawing but an existing layer was touched.
        // If a user selected via joint/joiner pixel, we assume they do
        // want to draw from it.
        if (
          selectedLayer &&
          !selectedLayer.hasJointPixel(event.target.id) &&
          !selectedLayer.hasJoinerPixel(event.target.id)
        ) {
          modeMaster.reset("select");
          Layer.selectMouseDownEvent(event);
          return true;
        }
        return false;
      }

      static drawMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let selectedLayer = layerManager.getLayerByPixelId(activePixel.id());
        if (Layer.drawToSelectMouseDownEvent(event, selectedLayer)) return;

        // Otherwise we go ahead and create a new layer.
        let layerType = modeMaster.getLayerType();
        let layerClass = layerManager.getLayerClassByType(layerType);
        let layer = new layerClass(event.target.id);
        layerManager.add(layer);
        layerManager.refresh(() => layer.draw(activePixel));
      }

      static drawingMouseOverEvent(event) {
        let layer = layerManager.getLatestLayer();
        let activePixel = canvas.getPixelById(event.target.id);
        // Extremely rare, but somehow activePixel can be undefined. TBC.
        if (!activePixel) return;
        layerManager.refresh(() => layer.draw(activePixel));
        layerManager.findJoints([layer]);
      }

      static drawMouseOver() {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layerOver = layerManager.getLayerByPixelId(activePixel.id());
        if (modeMaster.has("text") && (!layerOver || layerOver.is("text"))) {
          canvas.setCursor("text");
        } else if (layerOver) {
          canvas.setCursor("pointer");
        } else {
          canvas.setCursor("crosshair");
        }
      }

      static selectMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        let selectedLayers = layerManager.getSelectedLayers();

        layerManager.setSelectPixel(activePixel);
        // Unselect all if...
        // 1. clicked-off (no layer selected)
        // 2. Single select mode (not multi) and alternative layer picked.
        if (!layer || (!modeMaster.has("shift") && !layer.isSelected())) {
          layerManager.unselectAll();
          modeMaster.change("selected", "select");
        }
        if (!layer) {
          modeMaster.add("area-selecting");
          return;
        }
        layerManager.refresh(() => layer.select());
        modeMaster.change("select", "selected");
        modeMaster.setSelectedLayerMode(layer);
        modeMaster.add(layerManager.prepareLayerResizing(activePixel, layer) ? "resizing" : "moving");
        if (!modeMaster.has("ctrl") || layer.is("table") || layer.hasTable()) {
          // Select all members of a group if not bypassed by ctrl to select a grouped
          // layer.
          // This bypass shouldn't work for tables / table children to avoid undefined behaviour.
          layerManager.refresh(() => layerManager.selectGroupsByMemberLayer(layer));
        }
      }

      draw(activePixel) {
        let committed = this.commit(() => this.drawLayer(activePixel));
        if (committed && this.isJoinable()) this.resizeJoinerLayers(true);
      }

      isHappy() {
        // Anything that doesn't satisfy this condition will cause a rollback.
        // Currently, it just ensures pixels are valid, but it could be anything,
        // and extending this in specific layers is welcomed.
        return Boolean(
          this.pixels.every(Boolean) && this.getJointPixels().every(Boolean) && this.fromPixel && this.toPixel
        );
      }

      commit(...updateFuncs) {
        // Committing is used to trial ANY state changes of a layer.
        // The draw/move functions might recommend pixels that are out of bounds,
        // or in whatever way invalid. If the committed change (updateFuncs)
        // results in an 'unhappy' state, we rollback to the stashed state.

        // If a commit hasn't already started, we start one
        // by stashing the layer's current state.
        // Multiple commits can be applied, but only the first
        // between renders should be stashed.
        if (!this.isCommitting()) this.stash();

        this.beginCommit();

        // Take note of current joint pixels before a change
        // so that joiner layers can be found before they are potentially changed.
        this.lastKeyedJointPixels = this.getKeyedJointPixels();

        // Attempted  the requested changes
        updateFuncs.forEach(func => func());

        let isHappy = this.isHappy();

        // If the changes have caused an upset, rollback to previous state.
        if (!isHappy) this.rollback();

        // Inform the requester of the success of the change.
        return isHappy;
      }

      isCommitting() {
        return this.commitLock;
      }

      beginCommit() {
        this.commitLock = true;
      }

      releaseCommit() {
        this.commitLock = false;
      }

      stash() {
        // This is used to store / remember a layer's state in case a layer becomes unhappy.
        this.stashed = {};
        this.stashed.fromPixel = this.fromPixel;
        this.stashed.toPixel = this.toPixel;
        this.stashed.pixels = this.pixels.map(p => p);
        this.stashed.values = this.values.map(v => v);
      }

      rollback() {
        // This puts a layer back into it's last working state.

        // We can therefore lift the commit lock, so that future commits
        // stash happy states again.
        this.releaseCommit();

        // The actual rollback...
        this.fromPixel = this.stashed.fromPixel;
        this.toPixel = this.stashed.toPixel;
        this.pixels = this.stashed.pixels;
        this.values = this.stashed.values;
      }

      redraw() {
        this.drawLayer(this.toPixel, true);
      }

      select() {
        this._isSelected = true;
        this.renderSelected();
        if (layerManager.getSelectedLayers().length > 1) modeMaster.add("multi-select");
      }

      unselect() {
        this._isSelected = false;
        this.renderUnselected();
        if (layerManager.getSelectedLayers().length <= 1) modeMaster.remove("multi-select");
      }

      setToPixel(pixel) {
        this.toPixel = pixel;
      }

      setFromPixel(pixel) {
        this.fromPixel = pixel;
      }

      getLastPixel() {
        return this.pixels.length ? this.pixels[this.pixels.length - 1] : this.fromPixel;
      }

      getMiddlePixel() {
        return this.pixels.length ? this.pixels[roundHalf(this.pixels.length / 2)] : this.fromPixel;
      }

      getFirstPixel() {
        return this.pixels.length ? this.pixels[0] : this.fromPixel;
      }

      add(pixel, value) {
        if (!pixel) return;
        this.pixels.push(pixel);
        this.values.push(value);
        if (this.pixels.length != this.values.length) {
          debugError(`layer pixel/value mismatch: ${this.pixels} != ${this.values}`);
        }
      }

      getJointPixels() {
        return Object.values(this.getKeyedJointPixels());
      }

      // Implement if the shape can be joined to - a "joint" layer.
      // The keys should meaningful reflect the same part of a layer.
      // E.g the key "tl" should always represent the top left
      // corner pixel of a square.
      getKeyedJointPixels() {
        return {};
      }

      // Implement if the layer can join to another (e.g a line - a "joiner" layer)
      getJoinerPixels() {
        return [];
      }

      // Implement if the layer can be resized.
      // This will determine which pixels can be used to
      // resize a layer.
      getResizePixels() {
        return [];
      }

      // Implement if the layer can be resized.
      // This will determine which pixel to resize from,
      // given a resize point.
      getResizeOppositePixel() {
        return false;
      }

      hasTable() {
        return Boolean(this.tableId);
      }

      getTable() {
        return layerManager.getLayerById(this.tableId);
      }

      isResizable() {
        return Boolean(this.getResizePixels().length);
      }

      isJoinable() {
        return Boolean(this.getJointPixels().length);
      }

      isJoiner() {
        return Boolean(this.getJoinerPixels().length);
      }

      getNearestResizePixel(pixel) {
        return pixel.isNearestTo(this.getResizePixels());
      }

      getResizePixelIndex(targetPixel) {
        return this.getResizePixels()
          .map(pixel => pixel.id())
          .indexOf(targetPixel.id());
      }

      hasJoinerPixel(pixelId) {
        return this.getJoinerPixels()
          .map(pixel => pixel.id())
          .includes(pixelId);
      }

      hasJointPixel(pixelId) {
        return this.getJointPixels()
          .map(pixel => pixel.id())
          .includes(pixelId);
      }

      clear() {
        this.pixels.forEach(pixel => pixel.clear());
      }

      tidyJoints() {
        let keyedJoints = this.getKeyedJointPixels();
        for (let joint of this.joints) {
          let layer = layerManager.getLayerById(joint.layerId);
          if (layer) {
            let jointPixel = keyedJoints[joint.jointKey];
            if (jointPixel) {
              // If the joint of this.layer matches the joiner pixels of the joiner layer (if connected)
              if (
                layer
                  .getJoinerPixels()
                  .map(pixel => pixel.id())
                  .includes(jointPixel.id())
              ) {
                continue;
              } else {
                // This should not happen.
                // Case 1 - When a joint "steals" another joint. This is fine.
                debugError("had to unjoin dangling join: somehow disconnected");
              }
            } else {
              // This should not happen.
              // Case 1 - originally for tables only but they get unjoined now (when rows/cols are removed).
              debugError("had to unjoin dangling join: joint pixel gone");
            }
          } else {
            // This should not happen because joints get deleted when layers do.
            debugError("had to unjoin dangling join: joiner layer gone");
          }
          this.unjoin(joint.layerId, joint.jointKey);
        }
      }

      copy(identical = false) {
        let layerCopy = new this.constructor(this.fromPixel.id());
        layerCopy.setFromPixel(this.fromPixel);
        layerCopy.setToPixel(this.toPixel);
        layerCopy.pixels = this.pixels.map(pixel => pixel);
        layerCopy.values = this.values.map(value => value);

        // By default, a copied layer should appear infront of it's original.
        layerCopy.zindex = this.zindex + 1;

        layerCopy.lineForm = this.lineForm;

        if (identical) {
          // This is an exact copy, mainly used for capturing snapshots,
          // reverting history.
          // We only copy joints here, as other use cases need to manually
          // repoint joints to new layers.
          layerCopy.joints = this.joints.map(joint => structuredClone(joint));
          layerCopy.id = this.id;
          layerCopy.zindex = this.zindex;
        }
        return layerCopy;
      }

      copyAndRender() {
        let layerCopy = this.copy();
        layerManager.add(layerCopy);
        this.unselect();
        layerCopy.select();
        return layerCopy;
      }

      getNearOverlappingCount(targetLayer) {
        // Gets the amount of pixels which are common / the same (the amount of overlap).
        // Or, nearly the same by 1 pixel in any direction.
        var total = 0;
        if (targetLayer.id == this.id) return 0;
        let layerPixelIds = this.pixels.map(pixel => pixel.id());
        let directions = [
          [0, 0],
          [1, 1],
          [-1, 1],
          [1, -1],
          [-1, -1],
        ];
        for (let direction of directions) {
          total += targetLayer
            .getMove(...direction)
            .filter(pixel => pixel && layerPixelIds.includes(pixel.id())).length;
        }
        return total;
      }

      renderUnselected() {
        this.getJointPixels().forEach(pixel => pixel.renderWasSelected());
        this.pixels.forEach(pixel => pixel.renderUnselected());
      }

      renderSelected() {
        // Don't show joint pixels if the layer is selected.
        this.getJointPixels().forEach(pixel => pixel.renderWasSelected());
        this.pixels.forEach(pixel => pixel.renderSelected());
        this.getResizePixels().forEach(pixel => pixel.renderResizable());
      }

      render() {
        this.releaseCommit();
        this.isSelected() ? this.renderSelected() : this.renderUnselected();
        for (var i = 0; i < this.pixels.length; i++) this.pixels[i].setValue(this.values[i]);
      }

      getMove(verticalDiff, lateralDiff) {
        return this.pixels.map(pixel => canvas.getPixelByRowCol(pixel.row + verticalDiff, pixel.col + lateralDiff));
      }

      move(verticalDiff, lateralDiff) {
        this.pixels = this.getMove(verticalDiff, lateralDiff);
        // We must update the to/from pixels so that redraws happen at the new position.
        this.setFromPixel(canvas.getPixelByRowCol(this.fromPixel.row + verticalDiff, this.fromPixel.col + lateralDiff));
        this.setToPixel(canvas.getPixelByRowCol(this.toPixel.row + verticalDiff, this.toPixel.col + lateralDiff));
      }

      resizeJoinerLayers(resizeSelectedJoinerLayers = false) {
        // resizeSelectedJoinerLayers is used to determine what to do with a probe
        // joint layer if it's selected (as well as the main layer it's joint to).
        // Generally, it should resize as normal. However, if both layers are being
        // moved, moving should take precedence.

        // Only joint layers will have joints.
        for (let joint of this.joints) {
          let layer = layerManager.getLayerById(joint.layerId);

          // Depending on multi-select and the action being taken,
          // it effects if a selected probe join layer should be redrawn.
          // Moved layers don't need to, where as resized layers do.
          if (!layer || (!resizeSelectedJoinerLayers && layer.isSelected())) continue;

          let beforeJointPixel = this.lastKeyedJointPixels[joint.jointKey];
          let currentJointPixel = this.getKeyedJointPixels()[joint.jointKey];

          if (!currentJointPixel) {
            // This means the layer has changed in such a way that the joint pixel
            // is no longer available. It will get unjoined. This only should happen
            // with tables.
            debugError("joint pixel not found");
            this.unjoin(joint.layerId, joint.jointKey);
            return;
          }

          // Get the "from" pixel given the joint pixel before the main layer was moved.
          // We have to use the before JointPixel as the joint layer hasn't moved yet,
          // so that's where it's joining pixel still is.
          let fromPixel = layer.getResizeOppositePixel(beforeJointPixel);

          // The resize pixel may not get found if the main layer has
          // somehow moved without the jointed layer.
          if (!fromPixel) {
            debugError("resize pixel not found");
            return;
          }
          layer.setFromPixel(fromPixel);
          layer.draw(currentJointPixel);
        }
      }

      probeJoint(layer, jointKey, jointPixel) {
        let joinerPixels = this.getJoinerPixels();
        if (!joinerPixels.length) return;
        let visible = layerManager.layerPixelIsVisible(layer, jointPixel);
        var state = 0;
        for (var probePixel of joinerPixels) {
          if (visible && probePixel.isNear(jointPixel)) {
            state = 1;
            if (probePixel.is(jointPixel)) {
              state = 2;
              layer.join(this.id, jointKey);
              // Break to avoid unjoining in the following iteration.
              // Only one joiner/probe pixel of the same layer can join to the same jointPixel.
              break;
            }
          }
          layer.unjoin(this.id, jointKey);
        }
        return state;
      }

      join(layerId, jointKey) {
        for (var joint of this.joints) {
          if (layerId == joint.layerId && jointKey == joint.jointKey) {
            return;
          }
        }
        this.joints.push({ layerId: layerId, jointKey: jointKey });
      }

      unjoin(layerId, jointKey) {
        var index = 0;
        for (var joint of this.joints) {
          if (layerId == joint.layerId && jointKey == joint.jointKey) {
            this.joints.splice(index, 1);
            return;
          }
          index++;
        }
      }

      hasPixel(id) {
        return this.getPixelIndex(id) > -1;
      }

      usesPixel(id) {
        return this.hasPixel(id) || this.hasJointPixel(id);
      }

      getPixelIndex(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          let pixel = this.pixels[i];
          if (pixel.id() == id) return i;
        }
        return -1;
      }

      erasePixel(id) {
        for (var i = 0; i < this.pixels.length; i++) {
          if (this.pixels[i].id() == id) this.deletePixelByPosition(i);
        }
      }

      deletePixelByPosition(index) {
        this.pixels.splice(index, 1);
        this.values.splice(index, 1);
      }

      isSelected() {
        return this._isSelected;
      }

      empty() {
        this.pixels = [];
        this.values = [];
      }

      getMinMaxRowsCols() {
        var [maxCol, minCol, maxRow, minRow] = [-1, -1, -1, -1];
        for (var pixel of this.pixels) {
          if (pixel.col > maxCol) maxCol = pixel.col;
          if (pixel.col < minCol || minCol == -1) minCol = pixel.col;
          if (pixel.row > maxRow) maxRow = pixel.row;
          if (pixel.row < minRow || minRow == -1) minRow = pixel.row;
        }
        return [maxCol, minCol, maxRow, minRow];
      }
    }

    class TextLayer extends Layer {
      static type = "text";

      starterChar = ">";

      constructor(firstPixelId, tableId = null) {
        super(firstPixelId);
        this.contents = [];
        this.cursor = 0;
        this.tableId = tableId;
        if (tableId) this.zindex = this.getTable().zindex;
        // TextLayer's don't use toPixels, but it's easier to just set it.
        this.setToPixel(this.fromPixel);
      }

      static decode(encodedLayer) {
        let layer = Layer.decode(encodedLayer);
        layer.contents = encodedLayer.cts.split("");
        if (encodedLayer.tbl) layer.tableId = encodedLayer.tbl;
        return layer;
      }

      encode() {
        let encoded = super.encode();
        encoded.cts = this.contents.join("");
        if (this.tableId) encoded.tbl = this.tableId;
        return encoded;
      }

      static selectedDoubleClickEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        let layer = layerManager.getLayerByPixelId(activePixel.id());
        layerManager.editingTextLayer = layer;
        layer.moveCursorToPixel(activePixel);
      }

      static drawMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        // Check if we're trying to edit existing text...
        if (TextLayer.focusedOtherTextLayer(activePixel)) {
          return;
        }
        // Text if we might be just selecting another layer...
        let selectedLayer = layerManager.getLayerByPixelId(activePixel.id());
        if (selectedLayer) {
          if (Layer.drawToSelectMouseDownEvent(event, selectedLayer)) {
            return;
          }
        }
        // Finally, do as expected and create new text layer.
        let layer = new TextLayer(event.target.id);
        layerManager.add(layer);
        layerManager.editingTextLayer = layer;
        layer.setStarterChar();
        layerManager.refresh(() => layer.drawLayer());
        // Give an instant cursor position so it can be cleared
        // even if no writing was done.
        layer.lastCursorPixel = layer.fromPixel;
      }

      static writingMouseDownEvent(event) {
        let activePixel = canvas.getPixelById(event.target.id);
        if (!activePixel) return;
        if (!TextLayer.focusedOtherTextLayer(activePixel)) {
          modeMaster.change("writing", "draw");
          layerManager.unselectAll();
        }
      }

      static keyDownEvent(event) {
        var layer = layerManager.editingTextLayer;
        if (layer && layer.is("text")) layerManager.refresh(() => layer.draw(event.key));
        layerManager.triggerChanged();
      }

      static focusedOtherTextLayer(activePixel) {
        layerManager.tidyLayers(); // Incase an empty text layer was left behind.
        let layer = layerManager.getLayerByPixelId(activePixel.id());

        // Unselect / remove cursor from any previous editing text layer.
        if (layerManager.editingTextLayer) {
          layerManager.editingTextLayer.clearLastCursor();

          // If the current editing text is selected, it should become unselected given
          // a new text layer has been selected for editing, though in a table this doesn't make
          // visual sense as the whole table is selected as a group.
          if (layerManager.editingTextLayer.isSelected() && !layerManager.editingTextLayer.hasTable()) {
            layerManager.editingTextLayer.unselect();
          }
        }

        // Setup the newly selected layer (might be the same).
        if (layer && layer.is("text")) {
          layer.moveCursorToPixel(activePixel);
          layerManager.editingTextLayer = layer;
          return true;
        }
        return false;
      }

      isHappy() {
        if (this.hasTable()) {
          // If the textLayer has a parent table, it's happiness
          // should also depend on the parent (it should rollback if the parent has
          // become unhappy)
          return this.getTable().isHappy() && super.isHappy();
        }
        return super.isHappy();
      }

      clearLastCursor() {
        if (this.lastCursorPixel) this.lastCursorPixel.stopCursor();
      }

      copy(identical = false) {
        let layerCopy = super.copy(identical);
        layerCopy.contents = structuredClone(this.contents);
        if (identical) layerCopy.tableId = this.tableId;
        return layerCopy;
      }

      stash() {
        super.stash();
        this.stashed.cursor = this.cursor;
        this.stashed.contents = this.contents.map(c => c);
      }

      rollback() {
        super.rollback();
        this.cursor = this.stashed.cursor;
        this.contents = this.stashed.contents;
      }

      getKeyedJointPixels() {
        if (this.hasTable()) return {}; // The table itself will be joinable instead.
        let firstPixel = this.getFirstPixel();
        if (this.pixels.length < 2) return { l: firstPixel, r: firstPixel, t: firstPixel, b: firstPixel };
        let [maxCol, minCol, maxRow, minRow] = this.getMinMaxRowsCols();
        let halfwayRow = minRow + roundHalf((maxRow - minRow) / 2);
        let halfwayCol = minCol + roundHalf((maxCol - minCol) / 2);
        return {
          l: canvas.getPixelByRowCol(halfwayRow, minCol - 1), // Left
          r: canvas.getPixelByRowCol(halfwayRow, maxCol + 1), // Right
          t: canvas.getPixelByRowCol(minRow - 1, halfwayCol), // Top
          b: canvas.getPixelByRowCol(maxRow + 1, halfwayCol), // Bottom
        };
      }

      getLength() {
        return this.contents.length;
      }

      moveCursorToPixel(pixel) {
        this.clearLastCursor();
        let pixIndex = this.getPixelIndex(pixel.id());
        // Work out selected line using row diff from start.
        let line = pixel.row - this.fromPixel.row;
        // For each line, add a cursor position to make up for \n's.
        var cursor = pixIndex + line + 1;
        // If the user has selected the end, decrement the cursor once so that it
        // doesn't flip to the beginning.
        this.cursor = this.pixIndex == this.pixels.length - 1 ? cursor - 1 : cursor;
        this.lastCursorPixel = pixel;
        pixel.startCursor();
      }

      getCursorLineOffset() {
        for (var i = this.cursor; i >= 0; i--) {
          if (i == 0) {
            // If i can decrement to 0, it hasn't hit a \n, so it's the first line,
            // meaning the cursor itself is the offset.
            return this.cursor;
          } else if (this.contents[i] == "\n") {
            // If the cursor is at the new line, go to the previous by continuing.
            if (this.cursor - i == 0) continue;
            // Otherwise, we've reached the start of the line, so give the offset.
            return this.cursor - i - 1;
          }
        }
      }

      getCurrentLine() {
        var line = 0;
        for (var i = 0; i < this.getLength(); i++) {
          if (i == this.cursor || i + 1 == this.getLength()) return line;
          if (this.contents[i] == "\n") line++;
        }
        return 0;
      }

      getLineStart(lineNum) {
        var line = 0;
        for (var i = 0; i < this.getLength(); i++) {
          if (line == lineNum) return i;
          if (this.contents[i] == "\n") line++;
        }
        return i;
      }

      getLineLengths() {
        var lengths = [0];
        for (var i = 0; i < this.getLength(); i++) {
          if (this.contents[i] == "\n") {
            lengths.push(0);
          } else {
            lengths[lengths.length - 1]++;
          }
        }
        return lengths;
      }

      getVerticalCursor(direction) {
        let currentLine = this.getCurrentLine();
        let lineLengths = this.getLineLengths();
        let cursorLineOffset = this.getCursorLineOffset();
        var nextLine;
        if (direction == "up") {
          nextLine = currentLine > 0 ? currentLine - 1 : currentLine;
        } else {
          nextLine = lineLengths.length - 1 > currentLine ? currentLine + 1 : currentLine;
        }
        let col = lineLengths[nextLine] > cursorLineOffset ? cursorLineOffset : lineLengths[nextLine];
        return this.getLineStart(nextLine) + col;
      }

      draw(key) {
        let committed = this.commit(
          () => this.writeChar(key),
          () => this.drawLayer()
        );
        if (!committed) return;
        this.resizeJoinerLayers(true);
        this.updateParentTable();
      }

      updateParentTable() {
        if (this.hasTable()) this.getTable().drawRefreshSpacing(this.id);
      }

      writeChar(key) {
        let length = this.getLength();
        let currentLine = this.getCurrentLine();
        let lineLengths = this.getLineLengths();
        switch (key) {
          case "ArrowDown":
            this.cursor = this.getVerticalCursor("down");
            break;
          case "ArrowUp":
            this.cursor = this.getVerticalCursor("up");
            break;
          case "ArrowRight":
            this.cursor = this.cursor >= length ? length : this.cursor + 1;
            break;
          case "ArrowLeft":
            this.cursor = this.cursor <= 0 ? 0 : this.cursor - 1;
            break;
          case "Enter":
            if (this.contents.length == 0) return;
            this.contents.splice(this.cursor, 0, "\n");
            this.cursor++;
            break;
          case "Backspace":
          case "Delete":
            this.cursor = this.cursor <= 0 ? 0 : this.cursor - 1;
            this.contents.splice(this.cursor, 1);
            break;
          default:
            this.contents.splice(this.cursor, 0, key);
            this.cursor++;
            break;
        }
        this.checkNoWrites();
      }

      drawLayer(_, force = false) {
        // Ensure the cursor is cleared incase pre-render clearing
        // didn't (if the cursor isn't on the layer's pixel).
        this.clearLastCursor();
        this.empty();
        let pixels = [];
        var [line, col] = [0, 0];
        for (var i = 0; i < this.getLength(); i++) {
          if (this.contents[i] == "\n") {
            line++;
            col = 0;
          }
          let pixel = canvas.getPixelByRowCol(this.fromPixel.row + line, this.fromPixel.col + col);
          // Writing out of bounds. Stop the writing! Let a rollback take care of it.
          if (!pixel) return;

          // Draw the cursor if this isn't a redraw (forced).
          if (this.cursor == i + 1 && !force) {
            this.lastCursorPixel = pixel;
            pixel.startCursor();
          }
          if (!pixel || this.contents[i] == "\n") continue;
          this.add(pixel, this.contents[i]);
          col++;
        }
      }

      checkNoWrites() {
        // This is a quick way of not loosing a layer just because
        // a user backspaced all characters.
        let starterCharIndex = this.contents.indexOf(this.starterChar);
        if (this.noWrites && starterCharIndex == 0) {
          this.contents.splice(starterCharIndex, 1);
          this.cursor = 1;
          this.noWrites = false;
        }
        this.setStarterChar();
      }

      setStarterChar() {
        if (this.contents.length == 0) {
          this.contents = [this.starterChar];
          this.cursor = 1;
          this.noWrites = true;
        }
      }

      paste(text) {
        this.contents.splice(this.cursor, 0, ...text.split(""));
        this.checkNoWrites();
        this.cursor += text.length - 1;
        this.drawLayer();
      }
    }

    class BaseLineLayer extends Layer {
      static lineBased = true;
      static line = true;

      constructor(firstPixelId) {
        super(firstPixelId);
        this.hasArrowLeft = false;
        this.hasArrowRight = false;
      }

      static decode(encodedLayer) {
        let layer = Layer.decode(encodedLayer);
        layer.hasArrowLeft = encodedLayer.al;
        layer.hasArrowRight = encodedLayer.ar;
        return layer;
      }

      encode() {
        let encoded = super.encode();
        encoded.al = this.hasArrowLeft;
        encoded.ar = this.hasArrowRight;
        return encoded;
      }

      static drawMouseOver(event) {
        Layer.drawMouseOver(event);
        let activePixel = canvas.getPixelById(event.target.id);

        for (var layer of layerManager.layers) {
          for (var jointPixel of layer.getJointPixels()) {
            if (activePixel.isNear(jointPixel) && layerManager.layerPixelIsVisible(layer, jointPixel)) {
              jointPixel.renderJointNear();
              if (activePixel.is(jointPixel)) canvas.setCursor(modeMaster.has("text") ? "text" : "crosshair");
            } else {
              jointPixel.renderWasSelected();
            }
          }
        }
      }

      copy(identical = false) {
        let layerCopy = super.copy(identical);
        layerCopy.hasArrowLeft = this.hasArrowLeft;
        layerCopy.hasArrowRight = this.hasArrowRight;
        return layerCopy;
      }

      toggleArrows(direction) {
        if (direction == "left") this.hasArrowLeft = !this.hasArrowLeft;
        if (direction == "right") this.hasArrowRight = !this.hasArrowRight;
        this.redraw();
      }

      getEndPixels() {
        if (this.pixels.length > 0) {
          return [this.getFirstPixel(), this.getLastPixel()];
        }
        return [];
      }

      getResizePixels() {
        return this.getEndPixels();
      }

      getJoinerPixels() {
        return this.getEndPixels();
      }

      getResizeOppositePixel(pixel) {
        let resizePixels = this.getResizePixels();
        if (!resizePixels.length) return;
        if (pixel.is(resizePixels[0])) return resizePixels[1];
        if (pixel.is(resizePixels[1])) return resizePixels[0];
      }
    }

    class FreeLineLayer extends BaseLineLayer {
      static type = "free-line";

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        let fromPixel = this.fromPixel;
        let toPixel = this.toPixel;
        let verticalDiff = toPixel.row - fromPixel.row;
        let lateralDiff = toPixel.col - fromPixel.col;

        var totalSteps = Math.max(Math.abs(verticalDiff), Math.abs(lateralDiff));
        var verticalStep = verticalDiff / totalSteps;
        var lateralStep = lateralDiff / totalSteps;

        var colDraw = fromPixel.col;
        var rowDraw = fromPixel.row;

        var value = "x";

        if (Math.abs(verticalStep) < 0.3) {
          value = charManager.getLateralLine(this.lineForm);
        } else if (Math.abs(lateralStep) < 0.5) {
          value = charManager.getVerticalLine(this.lineForm);
        } else if (toPixel.isLeft(fromPixel) && toPixel.isBelow(fromPixel)) {
          value = charManager.getDiagForwardLine(this.lineForm);
        } else if (toPixel.isRight(fromPixel) && toPixel.isBelow(fromPixel)) {
          value = charManager.getDiagBackLine(this.lineForm);
        } else if (toPixel.isLeft(fromPixel) && toPixel.isAbove(fromPixel)) {
          value = charManager.getDiagBackLine(this.lineForm);
        } else if (toPixel.isRight(fromPixel) && toPixel.isAbove(fromPixel)) {
          value = charManager.getDiagForwardLine(this.lineForm);
        }

        var startValue = value;
        var endValue = value;
        // We double verticalDiff to give it a bias here,
        // as it looks better given width < height,
        // (~double pixels in same visual distance laterally).
        if (Math.abs(verticalDiff) * 2 > Math.abs(lateralDiff)) {
          if (toPixel.isAbove(fromPixel)) {
            endValue = this.hasArrowLeft ? charManager.getArrow("up") : value;
            startValue = this.hasArrowRight ? charManager.getArrow("down") : value;
          } else {
            endValue = this.hasArrowLeft ? charManager.getArrow("down") : value;
            startValue = this.hasArrowRight ? charManager.getArrow("up") : value;
          }
        } else {
          if (fromPixel.isLeft(toPixel)) {
            endValue = this.hasArrowRight ? charManager.getArrow("right") : value;
            startValue = this.hasArrowLeft ? charManager.getArrow("left") : value;
          } else {
            endValue = this.hasArrowLeft ? charManager.getArrow("left") : value;
            startValue = this.hasArrowRight ? charManager.getArrow("right") : value;
          }
        }

        this.empty();
        for (var i = 0; i <= totalSteps; i++) {
          this.add(canvas.getPixelByRowCol(roundHalf(rowDraw), roundHalf(colDraw)), i == 0 ? startValue : value);
          rowDraw += verticalStep;
          colDraw += lateralStep;
        }
        this.add(this.getLastPixel(), endValue);
      }
    }

    class StepLineLayer extends BaseLineLayer {
      static type = "step-line";

      getKeyedJointPixels() {
        var lastRow = this.getFirstPixel().row;
        var index = 0;
        for (var pixel of this.pixels) {
          if (pixel.row != lastRow) {
            return { m: this.pixels[index - 1] }; // Middle
          }
          index++;
        }
        return { m: this.getLastPixel() }; // Middle
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        /*
        Try and draw the step line both ways e.g
            _____
            |                |
            |       Vs.   ___|

        and choose which ever is more visible depending on other layers overlapping.
        */
        let layersToAvoid = [TextLayer.type, SquareLayer.type, CircleLayer.type, DiamondLayer.type, TableLayer.type];
        this.drawFromTo(this.fromPixel, this.toPixel);
        let resultNorm = layerManager.getNearOverlappingCount(this, layersToAvoid);
        this.drawFromTo(this.toPixel, this.fromPixel);
        let resultFlip = layerManager.getNearOverlappingCount(this, layersToAvoid);
        if (resultNorm > resultFlip) {
          this.drawFromTo(this.toPixel, this.fromPixel);
        } else {
          this.drawFromTo(this.fromPixel, this.toPixel);
        }
      }

      drawFromTo(fromPixel, toPixel) {
        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        this.empty();
        let verticalDiff = toPixel.row - fromPixel.row;
        let lateralDiff = toPixel.col - fromPixel.col;
        let absVerticalDiff = Math.abs(verticalDiff);
        let absLateralDiff = Math.abs(lateralDiff);

        let [lateralArrowValue, verticalArrowValue] = this.getArrowChars(fromPixel, toPixel);
        var cornerChar = this.getCornerChar(fromPixel, toPixel);

        var drawCol = fromPixel.col;
        var drawRow = fromPixel.row;

        for (var i = 0; i < absLateralDiff; i++) {
          this.add(canvas.getPixelByRowCol(fromPixel.row, drawCol), i == 0 ? lateralArrowValue : lateralChar);
          drawCol += lateralDiff / absLateralDiff;
        }

        if (verticalDiff && !lateralDiff) {
          cornerChar = verticalChar;
        } else if (!verticalDiff && lateralDiff) {
          cornerChar = lateralChar;
        }
        this.add(canvas.getPixelByRowCol(drawRow, drawCol), cornerChar);

        for (var i = 1; i <= absVerticalDiff; i++) {
          drawRow += verticalDiff / absVerticalDiff;
          let value = verticalDiff && lateralDiff ? cornerChar : verticalChar;
          this.add(
            canvas.getPixelByRowCol(drawRow, toPixel.col),
            i == absVerticalDiff ? verticalArrowValue : verticalChar
          );
        }
      }

      getCornerChar(fromPixel, toPixel) {
        if (fromPixel.col < toPixel.col) {
          return fromPixel.row < toPixel.row
            ? charManager.getCorner(this.lineForm, "top-right")
            : charManager.getCorner(this.lineForm, "bottom-right");
        }
        return fromPixel.row < toPixel.row
          ? charManager.getCorner(this.lineForm, "top-left")
          : charManager.getCorner(this.lineForm, "bottom-left");
      }

      getArrowChars(fromPixel, toPixel) {
        var lateralArrowValue = charManager.getLateralLine(this.lineForm);
        var verticalArrowValue = charManager.getVerticalLine(this.lineForm);
        if (fromPixel.col > toPixel.col) {
          // Vertical line is on left
          //    |
          //    |
          //    |____
          if (this.hasArrowRight) lateralArrowValue = charManager.getArrow("right");
          if (this.hasArrowLeft) {
            verticalArrowValue =
              fromPixel.row > toPixel.row ? charManager.getArrow("up") : charManager.getArrow("down");
          }
        } else {
          // Vertical line is on left
          //       |
          //       |
          //    ___|
          if (this.hasArrowLeft) lateralArrowValue = charManager.getArrow("left");
          if (this.hasArrowRight) {
            verticalArrowValue =
              fromPixel.row > toPixel.row ? charManager.getArrow("up") : charManager.getArrow("down");
          }
        }
        return [lateralArrowValue, verticalArrowValue];
      }
    }

    class SwitchLineLayer extends BaseLineLayer {
      static type = "switch-line";

      getKeyedJointPixels() {
        // This finds the two corners of a switch line.
        let firstPixel = this.getFirstPixel();
        if (this.pixels.length < 2) return { 0: firstPixel, 1: firstPixel };
        let joints = [];
        for (var index = 1; index < this.pixels.length - 1; index++) {
          let pixel = this.pixels[index];
          let lastPixel = this.pixels[index - 1];
          let nextPixel = this.pixels[index + 1];
          if (
            (lastPixel.row == pixel.row && pixel.row != nextPixel.row) ||
            (lastPixel.col == pixel.col && pixel.col != nextPixel.col)
          ) {
            joints.push(pixel);
          }
        }

        // This means the line is straight, so we just join to the middle.
        if (joints.length != 2) {
          let middlePixel = this.getMiddlePixel();
          return { 0: middlePixel, 1: middlePixel };
        }

        // This ensures the keys are the same for the meaningful locations,
        // regardless of a flip.
        let keyedJoints = {};
        if (joints[0].row > joints[1].row || joints[0].col > joints[1].col) {
          keyedJoints[0] = joints[0];
          keyedJoints[1] = joints[1];
        } else {
          keyedJoints[0] = joints[1];
          keyedJoints[1] = joints[0];
        }
        return keyedJoints;
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        let fromPixel = this.fromPixel;
        let toPixel = this.toPixel;
        let verticalDiff = toPixel.row - fromPixel.row;
        let lateralDiff = toPixel.col - fromPixel.col;
        let absVerticalDiff = Math.abs(verticalDiff);
        let absLateralDiff = Math.abs(lateralDiff);
        /*
        Try and draw the switch line both ways e.g
            _____
            |                 |
            |             ____|
         ___|       Vs.   |



        and choose which ever is more visible depending on other layers overlapping.
        If there aren't notable overlaps, choose based on which direction is favoured.
        */
        let layersToAvoid = [TextLayer.type, SquareLayer.type, CircleLayer.type, DiamondLayer.type, TableLayer.type];
        this.drawVertical(fromPixel, toPixel);
        let verticalOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
        this.drawLateral(fromPixel, toPixel);
        let lateralOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
        if (verticalOverlap > lateralOverlap) {
          this.drawLateral(fromPixel, toPixel);
        } else if (lateralOverlap > verticalOverlap) {
          this.drawVertical(fromPixel, toPixel);
        } else if (absVerticalDiff > absLateralDiff) {
          this.drawVertical(fromPixel, toPixel);
        } else {
          this.drawLateral(fromPixel, toPixel);
        }
      }

      drawVertical(fromPixel, toPixel) {
        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        let [firstChar, lastChar] = this.getArrowCharsVertical(fromPixel, toPixel);
        let [firstCornerChar, lastCornerChar] = this.getCornerCharsVertical(fromPixel, toPixel);
        this.drawFromTo(
          fromPixel.col,
          fromPixel.row,
          toPixel.col,
          toPixel.row,
          [verticalChar, lateralChar, firstChar, lastChar, firstCornerChar, lastCornerChar],
          (a, b) => canvas.getPixelByRowCol(a, b)
        );
      }

      drawLateral(fromPixel, toPixel) {
        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        let [firstChar, lastChar] = this.getArrowCharsLateral(fromPixel, toPixel);
        let [firstCornerChar, lastCornerChar] = this.getCornerCharsLateral(fromPixel, toPixel);
        this.drawFromTo(
          fromPixel.row,
          fromPixel.col,
          toPixel.row,
          toPixel.col,
          [lateralChar, verticalChar, firstChar, lastChar, firstCornerChar, lastCornerChar],
          (a, b) => canvas.getPixelByRowCol(b, a)
        );
      }

      drawFromTo(fromPixelCol, fromPixelRow, toPixelCol, toPixelRow, chars, pixelFunc) {
        this.empty();
        let [mainChar, midChar, firstChar, lastChar, firstCornerChar, lastCornerChar] = chars;
        let diffA = toPixelRow - fromPixelRow;
        let diffB = toPixelCol - fromPixelCol;
        let absDiffA = Math.abs(diffA);
        let absDiffB = Math.abs(diffB);
        var drawCol = fromPixelCol;
        var drawRow = fromPixelRow;
        /*
        The following three loops represent each part of a
        switch layer in order.

        E.g

        "Lateral"
                             __________
                             |     3
                   __________| 2
                       1

        "Vertical"

                        | 1
                        |
                        |____
                          2  |
                             | 3
                             |

        Note, the logic is the same both ways, but to draw laterally,
        this method is called with cols and rows swapped.
        It's quite confusing but I've found it works wonderfully.
        */

        let halfwayA = roundHalf(absDiffA / 2);
        // First line
        for (var i = 0; i < halfwayA; i++) {
          this.add(pixelFunc(drawRow, drawCol), i == 0 ? firstChar : mainChar);
          drawRow += diffA / absDiffA;
        }

        // If there is no middle line (no diff in a direction),
        // fill with a continuation pixel using mainChar.
        if (absDiffB == 0) {
          this.add(pixelFunc(drawRow, drawCol), mainChar);
        } else {
          // First corner
          this.add(pixelFunc(drawRow, drawCol), firstCornerChar);
          // Second line (middle)
          for (var i = 0; i < absDiffB - 1; i++) {
            drawCol += diffB / absDiffB;
            this.add(pixelFunc(drawRow, drawCol), midChar);
          }
          drawCol += diffB / absDiffB;
          // Second corner
          this.add(pixelFunc(drawRow, drawCol), lastCornerChar);
        }
        // Third line. We use a while to ensure the line is drawn all the way.
        // Otherwise, using, using another "halfwayA" might be uneven due to rounding.
        while (drawRow != toPixelRow) {
          drawRow += diffA / absDiffA;
          this.add(pixelFunc(drawRow, toPixelCol), mainChar);
        }

        // This will replace the last char with arrows if needed.
        this.add(pixelFunc(drawRow, toPixelCol), lastChar);
      }

      getArrowCharsVertical(fromPixel, toPixel) {
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        var firstChar = verticalChar;
        var lastChar = verticalChar;
        if (fromPixel.row < toPixel.row) {
          // Going down
          if (fromPixel.col < toPixel.col) {
            // Going right
            if (this.hasArrowRight) lastChar = charManager.getArrow("down");
            if (this.hasArrowLeft) firstChar = charManager.getArrow("up");
          } else {
            // Going left
            if (this.hasArrowLeft) lastChar = charManager.getArrow("down");
            if (this.hasArrowRight) firstChar = charManager.getArrow("up");
          }
        } else {
          // Going up
          if (fromPixel.col < toPixel.col) {
            // Going right
            if (this.hasArrowRight) lastChar = charManager.getArrow("up");
            if (this.hasArrowLeft) firstChar = charManager.getArrow("down");
          } else {
            // Going left
            if (this.hasArrowLeft) lastChar = charManager.getArrow("up");
            if (this.hasArrowRight) firstChar = charManager.getArrow("down");
          }
        }
        return [firstChar, lastChar];
      }

      getArrowCharsLateral(fromPixel, toPixel) {
        let lateralChar = charManager.getLateralLine(this.lineForm);
        var firstChar = lateralChar;
        var lastChar = lateralChar;
        if (fromPixel.col < toPixel.col) {
          // Going right
          if (this.hasArrowLeft) firstChar = charManager.getArrow("left");
          if (this.hasArrowRight) lastChar = charManager.getArrow("right");
        } else {
          // Going left
          if (this.hasArrowLeft) lastChar = charManager.getArrow("left");
          if (this.hasArrowRight) firstChar = charManager.getArrow("right");
        }
        return [firstChar, lastChar];
      }

      getCornerCharsVertical(fromPixel, toPixel) {
        if (fromPixel.row < toPixel.row) {
          // Going down
          if (fromPixel.col < toPixel.col) {
            // Going right
            return [
              charManager.getCorner(this.lineForm, "bottom-left"),
              charManager.getCorner(this.lineForm, "top-right"),
            ];
          }
          // Going left
          return [
            charManager.getCorner(this.lineForm, "bottom-right"),
            charManager.getCorner(this.lineForm, "top-left"),
          ];
        }
        // Going up
        if (fromPixel.col < toPixel.col) {
          // Going right
          return [
            charManager.getCorner(this.lineForm, "top-left"),
            charManager.getCorner(this.lineForm, "bottom-right"),
          ];
        }
        // Going left
        return [charManager.getCorner(this.lineForm, "top-right"), charManager.getCorner(this.lineForm, "bottom-left")];
      }

      getCornerCharsLateral(fromPixel, toPixel) {
        if (fromPixel.row < toPixel.row) {
          // Going down
          if (fromPixel.col < toPixel.col) {
            // Going right
            return [
              charManager.getCorner(this.lineForm, "top-right"),
              charManager.getCorner(this.lineForm, "bottom-left"),
            ];
          }
          // Going left
          return [
            charManager.getCorner(this.lineForm, "top-left"),
            charManager.getCorner(this.lineForm, "bottom-right"),
          ];
        }
        // Going up
        if (fromPixel.col < toPixel.col) {
          // Going right
          return [
            charManager.getCorner(this.lineForm, "bottom-right"),
            charManager.getCorner(this.lineForm, "top-left"),
          ];
        }
        // Going left
        return [charManager.getCorner(this.lineForm, "bottom-left"), charManager.getCorner(this.lineForm, "top-right")];
      }
    }

    class FreeLayer extends Layer {
      static type = "free";
      static freeChar = "█";

      warningUnicodeChars = ["█", "•"];

      static setFreeChar(char) {
        FreeLayer.freeChar = char;
      }

      static startFreeDraw() {
        layerManager.switchModeCallback();
        modeMaster.add(FreeLayer.freeChar);
      }

      static decode(encodedLayer) {
        let layer = Layer.decode(encodedLayer);
        layer.pixels = encodedLayer.pxs.map(pixelId => canvas.getPixelById(pixelId));
        layer.values = encodedLayer.vls;
        return layer;
      }

      encode() {
        let encoded = super.encode();
        encoded.pxs = this.pixels.map(pixel => pixel.id());
        encoded.vls = this.values;
        return encoded;
      }

      redraw() {} // FreeLayers are static and should not be redrawable

      characterWarning(value) {
        if (this.warningUnicodeChars.includes(value) && charManager.charsetForm != "unicode") {
          bodyComponent.informerComponent.report("Warning: using unicode character in non-unicode mode");
        }
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        var value = "";
        if (FreeLayer.freeChar == "_lines") {
          let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
          let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);

          if (verticalDiff > lateralDiff) {
            value = verticalChar;
          } else if (lateralDiff > verticalDiff) {
            value = lateralChar;
          }
        } else {
          value = FreeLayer.freeChar;
        }
        this.characterWarning(value);
        this.add(this.toPixel, value);
        this.setFromPixel(this.toPixel);
      }
    }

    class SquareBoundLayer extends Layer {
      static lineBased = true;

      getCornerPixels() {
        if (this.pixels.length == 0) {
          return [];
        }
        let [maxCol, minCol, maxRow, minRow] = this.getMinMaxRowsCols();
        return [
          canvas.getPixelByRowCol(minRow, minCol), // Top left
          canvas.getPixelByRowCol(minRow, maxCol), // Top right
          canvas.getPixelByRowCol(maxRow, maxCol), // Bottom right
          canvas.getPixelByRowCol(maxRow, minCol), // Bottom left
        ];
      }

      getResizePixels() {
        return this.getCornerPixels();
      }

      getResizeOppositePixel(targetPixel) {
        let corners = this.getResizePixels();
        let cornerMatchPixel = this.getResizePixelIndex(targetPixel);
        if (cornerMatchPixel == -1) return;
        let firstPixelIndex = cornerMatchPixel + 2;
        if (firstPixelIndex > 3) firstPixelIndex = firstPixelIndex - 4;
        return corners[firstPixelIndex];
      }
    }

    class CircleLayer extends Layer {
      static type = "circle";
      static lineBased = true;

      getKeyedJointPixels() {
        let firstPixel = this.getFirstPixel();
        if (this.pixels.length < 4)
          return {
            t: firstPixel,
            r: firstPixel,
            b: firstPixel,
            l: firstPixel,
          };
        let [leftPixel, rightPixel, topPixel, bottomPixel] = this.getCornerPixels();
        return {
          t: canvas.getPixelByRowCol(topPixel.row - 1, topPixel.col),
          r: canvas.getPixelByRowCol(rightPixel.row, rightPixel.col + 1),
          b: canvas.getPixelByRowCol(bottomPixel.row + 1, topPixel.col),
          l: canvas.getPixelByRowCol(leftPixel.row, leftPixel.col - 1),
        };
      }

      getCornerPixels() {
        var minCol;
        var maxCol;
        var minRow;
        var maxRow;
        for (let pixel of this.pixels) {
          if (!minCol || pixel.col < minCol.col) minCol = pixel;
          if (!maxCol || pixel.col > maxCol.col) maxCol = pixel;
          if (!minRow || pixel.row < minRow.row) minRow = pixel;
          if (!maxRow || pixel.row > maxRow.row) maxRow = pixel;
        }
        return [minCol, maxCol, minRow, maxRow];
      }

      getResizePixels() {
        return this.getCornerPixels();
      }

      getResizeOppositePixel(targetPixel) {
        let [minCol, maxCol, minRow, maxRow] = this.getCornerPixels();
        return canvas.getPixelByRowCol(
          minRow.row + roundHalf((maxRow.row - minRow.row) / 2),
          minCol.col + roundHalf((maxCol.col - minCol.col) / 2)
        );
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);

        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);

        this.empty();

        let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
        let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);
        var diff = verticalDiff > lateralDiff ? verticalDiff : roundHalf(lateralDiff / 2);
        var radius = diff;
        var [col, row] = [0, radius];
        var p = 1 - radius;
        while (col <= row) {
          for (var i = 0; i <= 1; i++) {
            // This so that we will in the lateral gaps given columns are factored by 2.
            this.add(canvas.getPixelByRowCol(this.fromPixel.row + row, this.fromPixel.col + col * 2 - i), lateralChar);
            this.add(canvas.getPixelByRowCol(this.fromPixel.row + row, this.fromPixel.col - col * 2 - i), lateralChar);
            this.add(canvas.getPixelByRowCol(this.fromPixel.row - row, this.fromPixel.col + col * 2 - i), lateralChar);
            this.add(canvas.getPixelByRowCol(this.fromPixel.row - row, this.fromPixel.col - col * 2 - i), lateralChar);
          }
          this.add(canvas.getPixelByRowCol(this.fromPixel.row + col, this.fromPixel.col + row * 2), verticalChar);
          this.add(canvas.getPixelByRowCol(this.fromPixel.row + col, this.fromPixel.col - row * 2), verticalChar);
          this.add(canvas.getPixelByRowCol(this.fromPixel.row - col, this.fromPixel.col + row * 2), verticalChar);
          this.add(canvas.getPixelByRowCol(this.fromPixel.row - col, this.fromPixel.col - row * 2), verticalChar);
          // A clever algorithm I found online that I don't really understand...
          // https://en.wikipedia.org/wiki/Midpoint_circle_algorithm
          col += 1;
          if (p < 0) {
            p += 2 * col + 1;
          } else {
            row -= 1;
            p += 2 * (col - row) + 1;
          }
        }
      }
    }

    class DiamondLayer extends Layer {
      static type = "diamond";
      static lineBased = true;

      getKeyedJointPixels() {
        let firstPixel = this.getFirstPixel();
        if (this.pixels.length < 4)
          return {
            t: firstPixel,
            r: firstPixel,
            b: firstPixel,
            l: firstPixel,
          };
        let [leftPixel, rightPixel, topPixel, bottomPixel] = this.getCornerPixels();
        return {
          t: topPixel,
          r: rightPixel,
          b: bottomPixel,
          l: leftPixel,
        };
      }

      getCornerPixels() {
        var minCol;
        var maxCol;
        var minRow;
        var maxRow;
        for (let pixel of this.pixels) {
          if (!minCol || pixel.col < minCol.col) minCol = pixel;
          if (!maxCol || pixel.col > maxCol.col) maxCol = pixel;
          if (!minRow || pixel.row < minRow.row) minRow = pixel;
          if (!maxRow || pixel.row > maxRow.row) maxRow = pixel;
        }
        return [minCol, maxCol, minRow, maxRow];
      }

      getResizePixels() {
        return this.getCornerPixels();
      }

      getResizeOppositePixel(targetPixel) {
        let [minCol, maxCol, minRow, maxRow] = this.getCornerPixels();
        return canvas.getPixelByRowCol(
          minRow.row + roundHalf((maxRow.row - minRow.row) / 2),
          minCol.col + roundHalf((maxCol.col - minCol.col) / 2)
        );
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);

        let diagBackChar = charManager.getDiagBackLine(this.lineForm);
        let diagForwardChar = charManager.getDiagForwardLine(this.lineForm);
        let cornerDiamondVerticalChar = charManager.getDiamondCorner(this.lineForm, "vertical");
        let cornerDiamondLateralChar = charManager.getDiamondCorner(this.lineForm, "lateral");

        let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
        let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);
        var diff = verticalDiff > lateralDiff ? verticalDiff : roundHalf(lateralDiff / 2);

        var middlePixel = this.fromPixel;

        let topPixel = canvas.getPixelByRowCol(middlePixel.row - diff, middlePixel.col);
        let leftPixel = canvas.getPixelByRowCol(middlePixel.row, middlePixel.col - diff * 2);
        let rightPixel = canvas.getPixelByRowCol(middlePixel.row, middlePixel.col + diff * 2);
        let bottomPixel = canvas.getPixelByRowCol(middlePixel.row + diff, middlePixel.col);

        let corners = [topPixel, leftPixel, rightPixel, bottomPixel];
        if (!corners.every(Boolean)) return;

        this.empty();
        this.add(corners[0], cornerDiamondLateralChar);
        this.add(corners[1], cornerDiamondVerticalChar);
        this.add(corners[2], cornerDiamondVerticalChar);
        this.add(corners[3], cornerDiamondLateralChar);
        for (var backCount = 1; backCount < diff; backCount++) {
          this.add(canvas.getPixelByRowCol(rightPixel.row - backCount, rightPixel.col - backCount * 2), diagBackChar);
          this.add(canvas.getPixelByRowCol(bottomPixel.row - backCount, bottomPixel.col - backCount * 2), diagBackChar);
        }
        for (var fCount = 1; fCount < diff; fCount++) {
          this.add(canvas.getPixelByRowCol(leftPixel.row - fCount, leftPixel.col + fCount * 2), diagForwardChar);
          this.add(canvas.getPixelByRowCol(bottomPixel.row - fCount, bottomPixel.col + fCount * 2), diagForwardChar);
        }
      }
    }

    class SquareLayer extends SquareBoundLayer {
      static type = "square";

      getKeyedJointPixels() {
        let fp = this.getFirstPixel();
        if (this.pixels.length < 2) {
          return {
            tl: fp,
            tr: fp,
            br: fp,
            bl: fp,
            l: fp,
            r: fp,
            b: fp,
            t: fp,
          };
        }
        let corners = this.getCornerPixels();
        let minRow = corners[0].row;
        let maxRow = corners[2].row;
        let minCol = corners[0].col;
        let maxCol = corners[2].col;
        let halfwayRow = parseInt((maxRow - minRow) / 2);
        let halfwayCol = parseInt((maxCol - minCol) / 2);
        return {
          tl: corners[0], // Top left
          tr: corners[1], // Top right
          br: corners[2], // Bottom right
          bl: corners[3], // Bottom left
          l: canvas.getPixelByRowCol(minRow + halfwayRow, minCol - 1), // Left
          r: canvas.getPixelByRowCol(minRow + halfwayRow, maxCol + 1), // Right
          b: canvas.getPixelByRowCol(maxRow + 1, minCol + halfwayCol), // Bottom
          t: canvas.getPixelByRowCol(minRow - 1, minCol + halfwayCol), // Top
        };
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);

        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        let cornerTopLeftChar = charManager.getCorner(this.lineForm, "top-left");
        let cornerTopRightChar = charManager.getCorner(this.lineForm, "top-right");
        let cornerBottomLeftChar = charManager.getCorner(this.lineForm, "bottom-left");
        let cornerBottomRightChar = charManager.getCorner(this.lineForm, "bottom-right");

        let topLeftPixel = canvas.getPixelByRowCol(
          Math.min(this.toPixel.row, this.fromPixel.row),
          Math.min(this.toPixel.col, this.fromPixel.col)
        );
        let bottomRightPixel = canvas.getPixelByRowCol(
          Math.max(this.toPixel.row, this.fromPixel.row),
          Math.max(this.toPixel.col, this.fromPixel.col)
        );

        let verticalDiff = bottomRightPixel.row - topLeftPixel.row;
        let lateralDiff = bottomRightPixel.col - topLeftPixel.col;

        if (!verticalDiff || !lateralDiff) return;

        let absVerticalDiff = Math.abs(verticalDiff);
        let absLateralDiff = Math.abs(lateralDiff);
        var rowPos = topLeftPixel.row;
        var colPos = topLeftPixel.col;

        this.empty();

        // Draw corners
        this.add(canvas.getPixelByRowCol(rowPos, colPos), cornerTopLeftChar);
        this.add(canvas.getPixelByRowCol(rowPos, bottomRightPixel.col), cornerTopRightChar);
        this.add(canvas.getPixelByRowCol(bottomRightPixel.row, colPos), cornerBottomLeftChar);
        this.add(canvas.getPixelByRowCol(bottomRightPixel.row, bottomRightPixel.col), cornerBottomRightChar);

        // Draw lines
        for (var row = 0; row < absVerticalDiff - 1; row++) {
          rowPos += verticalDiff / absVerticalDiff;
          this.add(canvas.getPixelByRowCol(rowPos, topLeftPixel.col), verticalChar);
          this.add(canvas.getPixelByRowCol(rowPos, bottomRightPixel.col), verticalChar);
        }
        for (var col = 0; col < absLateralDiff - 1; col++) {
          colPos += lateralDiff / absLateralDiff;
          this.add(canvas.getPixelByRowCol(topLeftPixel.row, colPos), lateralChar);
          this.add(canvas.getPixelByRowCol(bottomRightPixel.row, colPos), lateralChar);
        }
      }
    }

    class TableLayer extends SquareBoundLayer {
      static type = "table";

      constructor(firstPixelId) {
        super(firstPixelId);
        this.tblSizeLimit = 20;
        this.defaultCellContents = "text...";
        this.tblColDefaultWidth = this.defaultCellContents.length + 1; // 1 is added to account for the col line
        this.cellTextArchive = {};
        this.textLayers = {};
        this.tblRows = 0;
        this.tblCols = 0;
        this.tblColWidths = {};
        this.tblRowHeights = {};
        this.tblRowDefaultHeight = 2;
      }

      // The next few methods all persist layer data for different reasons,
      // (Copying, commit stashing, and export encoding). Perhaps it could be
      // combined into a 'persist' object, but explicitness is good, right?
      // As this stuff grows, separation should be a blessing.

      static decode(encodedLayer) {
        let layer = Layer.decode(encodedLayer);
        layer.tblCols = encodedLayer.tblc;
        layer.tblRows = encodedLayer.tblr;
        layer.tblColWidths = encodedLayer.tblws;
        layer.tblRowHeights = encodedLayer.tblhs;
        layer.textLayers = encodedLayer.tbltx;
        return layer;
      }

      encode() {
        let encoded = super.encode();
        // This layer is more complex. we need to encode more stuff.
        encoded.tblc = this.tblCols;
        encoded.tblr = this.tblRows;
        encoded.tblws = this.tblColWidths;
        encoded.tblhs = this.tblRowHeights;
        encoded.tbltx = this.textLayers;
        return encoded;
      }

      stash() {
        super.stash();
        // This layer is more complex. we need to stash more stuff.
        this.stashed.textLayers = structuredClone(this.textLayers); // We watch out for mutation here.
        this.stashed.tblColWidths = structuredClone(this.tblColWidths);
        this.stashed.tblRowHeights = structuredClone(this.tblRowHeights);
        this.stashed.tblRows = this.tblRows;
        this.stashed.tblCols = this.tblCols;
      }

      rollback() {
        super.rollback();
        this.textLayers = this.stashed.textLayers;
        this.tblColWidths = this.stashed.tblColWidths;
        this.tblRowHeights = this.stashed.tblRowHeights;
        this.tblRows = this.stashed.tblRows;
        this.tblCols = this.stashed.tblCols;
      }

      copy(identical = false) {
        // We also copy textLayers if it's a full identical copy.
        let layerCopy = super.copy(identical);
        if (identical) layerCopy.textLayers = structuredClone(this.textLayers);

        // Copy row and col counts so that refresh() works immediately for copied tables.
        layerCopy.tblRows = this.tblRows;
        layerCopy.tblCols = this.tblCols;
        layerCopy.tblRowHeights = structuredClone(this.tblRowHeights);
        layerCopy.tblColWidths = structuredClone(this.tblColWidths);
        return layerCopy;
      }

      getKeyedJointPixels() {
        let pixels = {};
        var corners = this.getCornerPixels();
        if (!corners.length) return {};
        let [topLeftPixel, topRightPixel, bottomRightPixel, bottomLeftPixel] = corners;
        var rowPos = topLeftPixel.row + 1;
        var index = 0;
        for (let row = 0; row < this.tblRows; row++) {
          let height = this.getRowHeight(row);
          rowPos += height;
          let jointPos = rowPos - roundHalf(height / 2) - 1;
          pixels[`l-${index}`] = canvas.getPixelByRowCol(jointPos, topLeftPixel.col - 1); // Left
          pixels[`r-${index}`] = canvas.getPixelByRowCol(jointPos, topRightPixel.col + 1); // Right
          index++;
        }
        var colPos = topLeftPixel.col + 1;
        var index = 0;
        for (let col = 0; col < this.tblCols; col++) {
          let width = this.getColWidth(col);
          colPos += width;
          let jointPos = colPos - roundHalf(width / 2);
          pixels[`t-${index}`] = canvas.getPixelByRowCol(topLeftPixel.row - 1, jointPos); // Top
          pixels[`b-${index}`] = canvas.getPixelByRowCol(bottomLeftPixel.row + 1, jointPos); // Bottom
          index++;
        }
        return pixels;
      }

      getNewTblRows(verticalDiff) {
        // Showing/hiding a row depends on it's height, the direction of the mouse,
        // and the mouse travelling enough to justify show/hiding based on the row's height.
        // E.g, to hide a row, the mouse moves back by half it's height (or forward to show).
        let relVerticalDiff = verticalDiff - this.getTablePixelHeight();
        let belowRowHeight = this.getRowHeight(this.tblRows);
        let aboveRowHeight = this.getRowHeight(this.tblRows - 1);
        let nextRowHeight = relVerticalDiff > 0 ? belowRowHeight : aboveRowHeight;
        return Math.abs(this.tblRows + roundHalf(relVerticalDiff / nextRowHeight));
      }

      getNewTblCols(lateralDiff) {
        // Showing/hiding a column depends on it's height, the direction of the mouse,
        // and the mouse travelling enough to justify show/hiding based on the col's width.
        // E.g, to hide a column, the mouse moves back by half it's width (or forward to show).
        let relLateralDiff = lateralDiff - this.getTablePixelWidth();
        let belowColWidth = this.getColWidth(this.tblCols);
        let aboveColWidth = this.getColWidth(this.tblCols - 1);
        let nextColWidth = relLateralDiff > 0 ? belowColWidth : aboveColWidth;
        return Math.abs(this.tblCols + roundHalf(relLateralDiff / nextColWidth));
      }

      drawLayer(activePixel, force = false) {
        this.setToPixel(activePixel);
        let topLeftPixel = this.getTopLeftPixel();
        let bottomRightPixel = this.getBottomRightPixel();
        let newTblRows = this.getNewTblRows(bottomRightPixel.row - topLeftPixel.row);
        let newTblCols = this.getNewTblCols(bottomRightPixel.col - topLeftPixel.col);

        if (!force) {
          // Don't bother updating the table if no proper changes have been calculated.
          if (newTblRows == this.tblRows && newTblCols == this.tblCols) return;
          if (newTblCols == 0 || newTblRows == 0) return;
          // ...or if the size limit is hit...
          if (newTblRows >= this.tblSizeLimit || newTblCols >= this.tblSizeLimit) {
            bodyComponent.informerComponent.report("Table getting too big", "bad");
            return;
          }
        }

        // This sequence does one draw of the whole table.
        // We start by setting new row/col properties,
        // which represent how many rows/cols are visible.
        this.tblRows = newTblRows;
        this.tblCols = newTblCols;

        // We ungroup the existing layers as a new group will be
        // needed since layers might get removed/added.
        this.ungroup();

        // The table layer itself get's drawn.
        this.drawFrame(topLeftPixel);

        // All layers that should no longer be visible are removed,
        // though their contents preserved.
        this.emptyTextLayers();

        // New rows/cols get their new layers added.
        this.addTextLayers(topLeftPixel);

        // Depending on the new location of rows/cols, we must
        // shuffle around layers so they stick to the correct cell.
        this.moveTextLayers(topLeftPixel);

        // Finally, group the updated set of layers.
        this.group();
      }

      drawFrame(topLeftPixel) {
        this.empty();

        let lateralChar = charManager.getLateralLine(this.lineForm);
        let verticalChar = charManager.getVerticalLine(this.lineForm);
        let cornerTopLeftChar = charManager.getCorner(this.lineForm, "top-left");
        let cornerTopRightChar = charManager.getCorner(this.lineForm, "top-right");
        let cornerBottomLeftChar = charManager.getCorner(this.lineForm, "bottom-left");
        let cornerBottomRightChar = charManager.getCorner(this.lineForm, "bottom-right");

        let tblHeight = this.getTablePixelHeight();
        let tblWidth = this.getTablePixelWidth();
        let fromRow = topLeftPixel.row;
        let fromCol = topLeftPixel.col;
        let toRow = fromRow + tblHeight;
        let toCol = fromCol + tblWidth;

        // Draw corners...
        this.add(canvas.getPixelByRowCol(fromRow, fromCol), cornerTopLeftChar);
        this.add(canvas.getPixelByRowCol(fromRow, toCol), cornerTopRightChar);
        this.add(canvas.getPixelByRowCol(toRow, fromCol), cornerBottomLeftChar);
        this.add(canvas.getPixelByRowCol(toRow, toCol), cornerBottomRightChar);

        // Draw row lines with spacing based on text..
        // -----------------
        //
        // -----------------
        // -----------------
        var row = fromRow;
        for (var tblRow = 0; tblRow <= this.tblRows; tblRow++) {
          for (var col = fromCol + 1; col < toCol; col++) {
            this.add(canvas.getPixelByRowCol(row, col), lateralChar);
          }
          row += this.getRowHeight(tblRow);
        }
        // Draw col lines with spacing based on text..
        // |      |   |    |
        // |      |   |    |
        // |      |   |    |
        var col = fromCol;
        for (var tblCol = 0; tblCol <= this.tblCols; tblCol++) {
          for (var row = fromRow + 1; row < toRow; row++) {
            this.add(canvas.getPixelByRowCol(row, col), verticalChar);
          }
          col += this.getColWidth(tblCol);
        }
      }

      refreshSpacing(textLayerId) {
        let topLeftPixel = this.getTopLeftPixel();
        this.setNewTextSpacing(textLayerId);
        this.drawFrame(topLeftPixel);
        this.moveTextLayers(topLeftPixel);

        // Here, we update the from/to pixels so that redraws
        // draw from the correct places (given the table size has changed).
        let corners = this.getCornerPixels();
        this.setFromPixel(corners[0]);
        this.setToPixel(corners[2]);

        // The textLayer that has changed needs another chance to rollback
        // in case it's parent table has since become unhappy. Hence,
        // we carry out an empty commit.
        let textLayer = layerManager.getLayerById(textLayerId);
        textLayer.commit(() => {});
      }

      drawRefreshSpacing(textLayerId) {
        let committed = this.commit(() => this.refreshSpacing(textLayerId));
        if (committed) this.resizeJoinerLayers(true);
      }

      makeCellId(row, col) {
        return `${row},${col}`;
      }

      parseCellId(cellId) {
        return cellId.split(",");
      }

      ungroup() {
        // Ungroup all layers.
        let layers = this.getTextLayers().concat(this);
        if (!layers.every(Boolean)) return;
        layerManager.groupManager.ungroupLayers(layers);
      }

      group() {
        // Group all existing visible layers, and ensure the table is always selected together.
        let textLayers = this.getTextLayers();
        if (this.isSelected()) textLayers.forEach(layer => layer.select());
        layerManager.groupManager.groupLayers(textLayers.concat(this));
      }

      getBottomRightPixel() {
        return canvas.getPixelByRowCol(
          Math.max(this.toPixel.row, this.fromPixel.row),
          Math.max(this.toPixel.col, this.fromPixel.col)
        );
      }

      getTopLeftPixel() {
        return canvas.getPixelByRowCol(
          Math.min(this.toPixel.row, this.fromPixel.row),
          Math.min(this.toPixel.col, this.fromPixel.col)
        );
      }

      getTextLayers() {
        return Object.values(this.textLayers).map(layerId => layerManager.getLayerById(layerId));
      }

      getCellFromTextLayerId(textLayerId) {
        for (let cellId in this.textLayers) {
          if (this.textLayers[cellId] == textLayerId) return this.parseCellId(cellId);
        }
      }

      getTablePixelHeight() {
        var height = 0;
        for (let row = 0; row < this.tblRows; row++) height += this.getRowHeight(row);
        return height;
      }

      getTablePixelWidth() {
        var width = 0;
        for (let col = 0; col < this.tblCols; col++) width += this.getColWidth(col);
        return width;
      }

      getRowHeight(row) {
        return this.tblRowHeights[row] || this.tblRowDefaultHeight;
      }

      getColWidth(col) {
        return this.tblColWidths[col] || this.tblColDefaultWidth;
      }

      setRowHeight(row, height) {
        this.tblRowHeights[row] = height;
      }

      setColWidth(col, width) {
        this.tblColWidths[col] = width;
      }

      emptyTextLayers() {
        for (let cellId in this.textLayers) {
          if (!this.cellIsVisible(cellId)) this.archiveCell(cellId);
        }
      }

      cellIsVisible(cellId) {
        let [row, col] = this.parseCellId(cellId);
        return row < this.tblRows && col < this.tblCols;
      }

      archiveCell(cellId) {
        let textLayer = this.getTextLayer(cellId);
        this.cellTextArchive[cellId] = textLayer.contents;
        textLayer.commit(() => textLayer.empty());
        delete this.textLayers[cellId];
      }

      reviveCell(cellId, absRow, absCol) {
        let textLayer = new TextLayer(canvas.getPixelByRowCol(absRow, absCol).id(), this.id);
        textLayer.contents = this.cellTextArchive[cellId] || this.defaultCellContents.split("");
        layerManager.addSecond(textLayer);
        this.textLayers[cellId] = textLayer.id;
        textLayer.commit(() => textLayer.drawLayer());
      }

      getTextLayer(cellId) {
        return layerManager.getLayerById(this.textLayers[cellId]);
      }

      setNewTextSpacing(textLayerId) {
        let [cellRow, cellCol] = this.getCellFromTextLayerId(textLayerId);
        // For the row and column that has a change, reset the height/widths for a fresh count.
        this.setRowHeight(cellRow, 0);
        this.setColWidth(cellCol, 0);
        for (let cellId in this.textLayers) {
          let [row, col] = this.parseCellId(cellId);
          // If the edited text is not on the same row or column as this text,
          // we don't need to consider it.
          if (row != cellRow && col != cellCol) continue;
          let lineLengths = this.getTextLayer(cellId).getLineLengths();
          let [textHeight, textWidth] = [lineLengths.length + 1, Math.max(...lineLengths) + 1];
          // If the row is on the edited text's row, consider it's height as the new tallest.
          if (row == cellRow && textHeight > this.tblRowHeights[row]) this.setRowHeight(row, textHeight);
          // If the col is on the edited text's col, consider it's width as the new longest.
          if (col == cellCol && textWidth > this.tblColWidths[col]) this.setColWidth(col, textWidth);
        }
      }

      addTextLayers(topLeftPixel) {
        var absRow = topLeftPixel.row;
        var absCol = topLeftPixel.col;
        for (var tblRow = 0; tblRow < this.tblRows; tblRow++) {
          for (var tblCol = 0; tblCol < this.tblCols; tblCol++) {
            let cellId = this.makeCellId(tblRow, tblCol);
            var textLayer = this.getTextLayer(cellId);
            // If a table rollback caused a TextLayer to empty (but it becomes visible again),
            // we must ensure it is redrawn here.
            if (textLayer && !textLayer.pixels.length) {
              textLayer.commit(() => textLayer.drawLayer());
            }
            // If the layer doesn't exist, add a new layer and fill it with any
            // saved content from the past at the same cell location.
            if (!textLayer) this.reviveCell(cellId, 1 + absRow, 1 + absCol);
            absCol += this.getColWidth(tblCol);
          }
          absCol = topLeftPixel.col;
          absRow += this.getRowHeight(tblRow);
        }
      }

      moveTextLayers(topLeftPixel) {
        var absRow = topLeftPixel.row;
        var absCol = topLeftPixel.col;
        for (var tblRow = 0; tblRow < this.tblRows; tblRow++) {
          for (var tblCol = 0; tblCol < this.tblCols; tblCol++) {
            let textLayer = this.getTextLayer(this.makeCellId(tblRow, tblCol));
            // Add 1s here to locate the text within the cell.
            let verticalDiff = 1 + absRow - textLayer.fromPixel.row;
            let lateralDiff = 1 + absCol - textLayer.fromPixel.col;
            // If the cell has changed position, then move the layer.
            if (verticalDiff || lateralDiff) {
              textLayer.commit(() => textLayer.move(verticalDiff, lateralDiff));
            }
            absCol += this.getColWidth(tblCol);
          }
          absCol = topLeftPixel.col;
          absRow += this.getRowHeight(tblRow);
        }
      }
    }

    /////////////////////
    //// COMPONENTS /////
    /////////////////////

    class Component {
      _MagicMethodEventPrefix = "on";
      _MagicPropCssPrefix = "css";
      _MagicPropCustomPrefix = "prop";

      value = "";
      children = [];
      type = "div";

      // Use this if you don't want a component's children to be traversed for theme setting.
      skipChildrenTheme = false;

      constructor(props) {
        this.visible = true;
        if (props) for (let prop in props) this[prop] = props[prop];
      }

      create() {
        this.element = document.createElement(this.type);
      }

      registerMagicProps() {
        var obj = this;
        // Get all properties
        let props = Object.keys(obj);

        // Get all methods
        let allMethods = new Set();
        while ((obj = Reflect.getPrototypeOf(obj))) {
          let keys = Reflect.ownKeys(obj);
          keys.forEach(key => allMethods.add(key));
        }
        props = props.concat(Array.from(allMethods.values()));

        // Assign magic functionality to each magic property type
        let mainProps = props.filter(prop => prop.includes("_"));

        // TODO: Consider if this priority logic is worth while.
        // If there is an intermediate class, Javascript constructors initialize
        // class properties of that class after the base constructor is called :/
        // This overrides properties being reasonably sent from a child class.
        // Here, we hack together a 'feature' where we can capitalize the derived property's
        // first letter so it takes priority.
        let highPriorProps = mainProps.filter(prop => /^[A-Z]*$/.test(prop.substring(0, 1)));
        let lowPriorProps = mainProps.filter(prop => /^[a-z]*$/.test(prop.substring(0, 1)));

        for (let prop of lowPriorProps.concat(highPriorProps)) {
          let [type, name] = prop.split("_");
          switch (type.toLowerCase()) {
            case this._MagicPropCustomPrefix:
              this.element.setAttribute(name, this[prop]);
            case this._MagicPropCssPrefix:
              this.css(name, this[prop]);
            case this._MagicMethodEventPrefix:
              this.element.addEventListener(name.toLowerCase(), () => this[prop]());
              break;
          }
        }
      }

      renderChildren() {
        this.children = this.defineChildren();
        for (let child of this.children) {
          child.render(this);
        }
      }

      defineChildren() {
        return this.children;
      }

      defineTheme() {}

      renderTheme() {
        this.defineTheme();
        if (this.skipChildrenTheme) return;
        this.children.forEach(child => child.renderTheme());
      }

      renderCallback() {}

      id() {
        return "";
      }

      assignParent(parent) {
        this.parent = parent;
        this.parent[this.accessibleBy] = this;
        this.parent.element.appendChild(this.element);
      }

      render(parent) {
        this.create();
        this.setId();
        this.setValue(this.value);
        this.registerMagicProps();
        this.renderChildren();
        this.assignParent(parent);
        this.renderTheme();
        this.renderCallback();
      }

      addChild(child) {
        this.children.push(child);
        child.render(this);
      }

      css(style, value) {
        // Check for priority styles
        if (this["Css_" + style] != undefined) value = this["Css_" + style];

        let valueFromTheme = themeManager.getTheme()[value];
        this.element.style[style] = valueFromTheme ? valueFromTheme : value;
      }

      setId() {
        let id = this.id();
        if (id) this.element.id = id;
      }

      setValue(value) {
        this.value = value;
        this.element.value = value;
        this.element.innerHTML = value;
      }

      getValue() {
        return this.element.value;
      }

      show() {
        this.visible = true;
        this.css("display", "block");
      }

      hide() {
        this.visible = false;
        this.css("display", "none");
      }

      toggle() {
        this.visible ? this.hide() : this.show();
      }
    }

    class Pixel extends Component {
      // It's no question that using DOM elements to represent a pixel is pretty CPU intensive.
      // Pixel and Canvas classes should eventually rewritten to interface something
      // more optimal.
      type = "pixel";

      css_position = "absolute";
      css_borderRight = "1px solid";
      css_borderTop = "1px solid";

      constructor(row, col) {
        super();
        this.row = row;
        this.col = col;
        this.cursorFlashInterval = null;
        this.selected = false;
      }

      id() {
        return Pixel.makeId(this.row, this.col);
      }

      is(pixel) {
        return this.id() == pixel.id();
      }

      static makeId(row, col) {
        return `px@${row}/${col}`;
      }

      renderSelected() {
        this.selected = true;
        this.css("backgroundColor", "pixelSelectedBgColor");
        this.css("color", "pixelSelectedFgColor");
      }

      renderUnselected() {
        this.selected = false;
        this.css("backgroundColor", "pixelNormalBgColor");
        this.css("color", "pixelNormalFgColor");
      }

      renderResizable() {
        this.css("backgroundColor", "pixelResizeBgColor");
        this.css("borderRadius", "10px");
      }

      renderAreaSelected() {
        this.css("backgroundColor", "areaSelectionBgColor");
      }

      renderJoint() {
        this.css("backgroundColor", "pixelJointBgColor");
        this.css("borderRadius", "10px");
      }

      renderJointNear() {
        this.css("backgroundColor", "pixelJointNearBgColor");
        this.css("borderRadius", "10px");
      }

      renderWasSelected() {
        this.selected ? this.renderSelected() : this.renderUnselected();
      }

      stopCursor() {
        this.renderNoCursor();
        if (this.cursorFlashInterval) clearInterval(this.cursorFlashInterval);
      }

      renderNoCursor() {
        this.setBorderColor();
      }

      defineTheme() {
        this.setBorderColor();
      }

      setBorderColor() {
        this.css("borderColor", this.getBorderColor());
      }

      getBorderColor() {
        return localStorage.getItem("grid") ? "gridColor" : "transparent";
      }

      renderCursor() {
        this.css("borderRightColor", "pixelCursorColor");
        this.css("borderTopColor", this.getBorderColor());
      }

      startCursor() {
        this.renderCursor();
        setTimeout(() => this.renderNoCursor(), 500);
        this.cursorFlashInterval = setInterval(
          pixel => {
            pixel.renderCursor();
            setTimeout(() => pixel.renderNoCursor(), 500);
          },
          1000,
          this
        );
      }

      renderNormal() {
        this.stopCursor();
        this.css("color", "pixelNormalFgColor");
        this.css("backgroundColor", "pixelNormalBgColor");
        this.css("borderRadius", "0px");
      }

      clear() {
        this.setValue("");
        this.renderNormal();
      }

      isAbove(pixel) {
        return this.row < pixel.row;
      }

      isBelow(pixel) {
        return this.row > pixel.row;
      }

      isLeft(pixel) {
        return this.col < pixel.col;
      }

      isRight(pixel) {
        return this.col > pixel.col;
      }

      isNear(pixel, distance = 6) {
        return Math.abs(pixel.row - this.row) <= distance && Math.abs(pixel.col - this.col) <= distance;
      }

      isNearestTo(pixels) {
        var closestPixel;
        var minDistance = -1;
        for (var pixel of pixels) {
          let distance = Math.abs(pixel.row - this.row) + Math.abs(pixel.col - this.col);
          if (distance < minDistance || minDistance == -1) {
            closestPixel = pixel;
            minDistance = distance;
          }
        }
        return closestPixel;
      }

      scale(size, widthDivider) {
        this.css("marginLeft", `${this.col * size * widthDivider}px`);
        this.css("marginTop", `${this.row * size}px`);
        this.css("height", `${size}px`);
        this.css("width", `${size * widthDivider}px`);
      }

      renderCallback() {
        this.renderNormal();
        this.scale();
      }
    }

    class CanvasComponent extends Component {
      accessibleBy = "canvasComponent";

      rowCount = 65;
      colCount = 225;

      css_userSelect = "none";
      css_webkitUserSelect = "none";
      css_position = "absolute";
      css_zIindex = "0";
      pixelWidthDivider = 0.5;

      constructor() {
        super();
        this.pixels = {};
      }

      calcPixelSize() {
        return roundDown(window.innerWidth / this.colCount / this.pixelWidthDivider);
      }

      getPixelById(id) {
        // This method is used under the assumption the ID does exist.
        // If it doesn't, we need to find out why.
        let pixel = this.pixels[id];
        if (!pixel) debugError(`Pixel with id ${id} not found`);
        return pixel;
      }

      getPixelByRowCol(row, col) {
        // This method is only used when prepared for an undefined result.
        return this.pixels[Pixel.makeId(row, col)];
      }

      clearPixels(pixels) {
        pixels.forEach(pixel => pixel.clear());
      }

      clear() {
        for (var pixel in this.pixels) this.pixels[pixel].clear();
      }

      setModeCursor() {
        if (modeMaster.hasOr("moving", "resizing")) {
          this.setCursor("move");
        } else if (modeMaster.hasOr("writing", "text")) {
          this.setCursor("text");
        } else if (modeMaster.hasOr("draw", "drawing")) {
          this.setCursor("crosshair");
        } else if (modeMaster.hasOr("erase", "erasing")) {
          this.setCursor("pointer");
        } else {
          this.setCursor("default");
        }
      }

      setCursor(cursor) {
        this.css("cursor", cursor);
      }

      getCroppedRowsCols() {
        var maxCol = -1;
        var minCol = this.colCount;
        var maxRow = -1;
        var minRow = this.rowCount;
        for (let pixelId in this.pixels) {
          let pixel = this.pixels[pixelId];
          if (pixel.getValue() != "") {
            if (pixel.col > maxCol) maxCol = pixel.col;
            if (pixel.col < minCol) minCol = pixel.col;
            if (pixel.row > maxRow) maxRow = pixel.row;
            if (pixel.row < minRow) minRow = pixel.row;
          }
        }
        return [maxCol, minCol, maxRow, minRow];
      }

      async exportToClipboard() {
        layerManager.switchModeCallback();
        // Scrape text from canvas with linebreaks
        var text = "";
        let [maxCol, minCol, maxRow, minRow] = this.getCroppedRowsCols();
        for (var row = minRow; row < maxRow + 1; row++) {
          var rowText = "";
          for (var col = minCol; col < maxCol + 1; col++) {
            let pixel = this.getPixelByRowCol(row, col);
            let pixelValue = pixel.getValue();
            let value = pixelValue == "" ? " " : pixelValue;
            rowText += value;
          }
          text += `${rowText}\n`;
        }

        let shortKey = await externalHookManager.getShortKeyUrl();
        if (shortKey.length > 0) {
          text += `\n\nEdit/view: ${shortKey}\n`;
        }

        // This is a slight hack to preserve styles if possible.
        // It fills scraped export text into a dump div styled nicely,
        // then copies it literally from there.
        // This allows same-browser exports to preserve styling.
        bodyComponent.canvasDumpComponent.setValue(text);
        var selection = window.getSelection();
        var range = document.createRange();
        range.selectNodeContents(bodyComponent.canvasDumpComponent.element);
        selection.removeAllRanges();
        selection.addRange(range);
        document.execCommand("copy");
        window.getSelection().removeAllRanges();
        bodyComponent.informerComponent.report("Successfully copied work to clipboard!", "good");
      }

      defineTheme() {
        this.css("backgroundColor", "canvasBgColor");
        this.css("fontFamily", "canvasFont");
      }

      on_mouseDown() {
        bodyComponent.hidePopups();
      }

      defineChildren() {
        for (var row = 0; row < this.rowCount; row++) {
          for (var col = 0; col < this.colCount; col++) {
            let pixel = new Pixel(row, col);
            this.pixels[pixel.id()] = pixel;
          }
        }
        return Object.values(this.pixels);
      }

      scale() {
        let pixelSize = this.calcPixelSize();
        this.css("width", `${this.colCount * pixelSize * this.pixelWidthDivider}px`);
        this.css("height", `${this.rowCount * pixelSize}px`);
        this.css("fontSize", `${pixelSize}px`);
        Object.values(this.pixels).forEach(pixel => pixel.scale(pixelSize, this.pixelWidthDivider));
      }

      renderCallback() {
        this.scale();
        modeMaster.registerCallback(() => this.setModeCursor());
      }

      toggleGrid() {
        localStorage.setItem("grid", localStorage.getItem("grid") ? "" : "true");
        this.renderTheme();
      }
    }

    class PopupComponent extends Component {
      css_boxShadow = "0px 0px 20px #403f3f";
      css_borderRadius = "10px";
      css_padding = "15px";
      css_backgroundColor = "bodyBgColor";
      css_position = "absolute";
      css_zIndex = "100";
      css_marginTop = "15vh";
      css_userSelect = "none";

      isPopup = true;
      disableModes = false;

      show() {
        bodyComponent.hidePopups();
        if (this.disableModes) modeMaster.reset();
        super.show();
      }

      renderCallback() {
        this.hide();
      }

      defineTheme() {
        this.css("background", "bodyBgColor");
      }
    }

    class HelpComponent extends PopupComponent {
      accessibleBy = "helpComponent";

      css_width = "500px";
      css_height = "500px";
      css_marginLeft = "calc(50vw - 250px)";
      css_overflow = "scroll";
      css_scrollbarWidth = "none";
      value = `
    <div style='text-align: center;'><h2>Cascii</h2>
    <h3>${VERSION}</h3>
    <p>
    This is one of the few well-equipped ASCII diagram builders freely available on the internet.
    It stresses portability, simplicity, and immediateness. ASCII diagrams are
    the best balance between pen to paper and advanced graphical builders, while also allowing
    users to present visual information in places that can
    only render text (such as in code, consoles, primitive displays, and so on).
    </p>
    <p>
    By using text, you avoid the need for file formats, attaching documents and over-styled distractions.
    </p>
    <h2>FAQ</h2>
     <h4>ASCII or Unicode?</h4>
     Unicode is prettier but less reliable. Depending on where it's used,
     it could display in unexpected ways. Here, both modes try their best
     to use the most appropriate characters, but each mode does not promise
     absolute ASCII or Unicode. You can change mode in Settings.
     <h4>How do I export my drawing?</h4>
     Simply select Export on the top menu, and your drawing
     will be copied to your clipboard. If using the hosted version, a short link will be included
     so that you / others can edit the drawing later. It's recommended
     you keep this short link to avoid loosing the ability to find / edit it later.
     Exported drawings are immutable; editing via a short link is a copy of the original.
     <br><br>
     <b>Remember, the view in which you paste the drawing must use a fixed-width font,
     and have a width greater than what you've drawn or not wrap text.
     Otherwise you'll see a mess.</b>

     <h4>What is Base64 I/O?</h4>
     If you want to simply save your drawings without using the online version (short links and user accounts),
     you can export it as Base64, save that anywhere, and import it later so that Cascii can remember your
     drawing's state.

     <h4>Why sign up?</h4>
     If using Cascii locally, please see <a href="cascii.app">cascii.app</a> to sign up.
     Only sign up if you care about managing and tracking your drawings.
     For convenience, your active drawing is saved to the browser, but
     to save multiple reliably and cross-device, an account is recommended.
     <h4>Account Management</h4>
     If you wish to delete your account, recover a lost account, or anything else,
     please get in touch at <b>casparwylie@gmail.com</b>, using the email you
     originally signed up with.
     <h4>How do I contribute?</h4>
     Feel free to contribute or report problems on <a href="https://github.com/casparwylie/cascii-core">GitHub</a>.
    <h2>Shortcuts</h2>
    </div>
    <span style='white-space: pre-wrap'>
    ctrl-g              Group
    ctrl-c              Copy layer
    ctrl-z              Undo
    ctrl-shift-z        Redo
    ctrl-a              Select all
    ctrl-v              Paste text
    ctrl-click          Single-select member of group
    shift-click         Multi-select
    backspace/delete    Delete layer
    arrow keys          Move layer / navigate text
    </span>
      `;

      defineChildren() {
        return [];
      }

      showForMobile() {
        this.css("marginLeft", "0vh");
        this.css("marginTop", "0vh");
        this.css("height", "100vh");
        this.css("width", "100vw");
        this.show();
      }
    }

    class Base64IOComponent extends PopupComponent {
      disableModes = true;
      accessibleBy = "base64IOComponent";
      css_width = "300px";
      css_height = "250px";
      css_marginLeft = "calc(50vw - 150px)";

      defineChildren() {
        return [
          new Component({
            css_width: "100%",
            css_height: "15%",
            css_textAlign: "center",
            value: "<h2>Export/import encoded</h2>",
          }),
          new ButtonComponent({
            value: "<b>Export current drawing as base64 <b>",
            css_width: "50%",
            css_marginLeft: "25%",
            on_click: () => this.exportBase64ToClipboard(),
          }),
          new Component({
            css_textAlign: "center",
            css_marginTop: "30px",
            value: "...Or...",
          }),
          new InputComponent({
            accessibleBy: "importContentComponent",
            css_borderRadius: "10px",
            css_marginTop: "10px",
            prop_placeholder: "Paste base64...",
            css_width: "100%",
          }),
          new ButtonComponent({
            value: "Import!",
            css_marginTop: "10px",
            css_width: "50%",
            css_marginLeft: "25%",
            on_click: () => this.importFromBase64(),
          }),
        ];
      }

      exportBase64ToClipboard() {
        let jsonData = layerManager.encodeAll();
        let base64Data = btoa(unescape(encodeURIComponent(jsonData)));
        navigator.clipboard.writeText(base64Data);
        bodyComponent.hidePopups();
        bodyComponent.informerComponent.report("Successfully copied Base64 encoded data to clipboard!", "good");
      }

      importFromBase64() {
        let base64Data = this.importContentComponent.getValue();
        if (base64Data.length < 1) return;
        var jsonData;
        try {
          jsonData = decodeURIComponent(escape(atob(base64Data)));
          layerManager.import(jsonData);
          externalHookManager.triggerDrawingChanged();
        } catch {
          bodyComponent.informerComponent.report("Failed to understand provided data :(", "bad");
          return;
        }
        bodyComponent.hidePopups();
        bodyComponent.informerComponent.report("Successfully loaded from Base64!", "good");
        this.importContentComponent.setValue("");
      }
    }

    class SettingsComponent extends PopupComponent {
      accessibleBy = "settingsComponent";

      css_width = "300px";
      css_height = "300px";
      css_marginLeft = "calc(50vw - 150px)";

      charsetButtons = [
        new ButtonComponent({
          charsetId: "ascii",
          selectByDefault: charManager.getCharset() == "ascii",
          value: "ASCII",
          css_width: "50%",
          on_click: () => this.setCharset("ascii"),
        }),
        new ButtonComponent({
          charsetId: "unicode",
          selectByDefault: charManager.getCharset() == "unicode",
          value: "Unicode",
          css_width: "50%",
          on_click: () => this.setCharset("unicode"),
        }),
      ];
      themeButtons = [
        new ButtonComponent({
          themeId: "darkTheme",
          selectByDefault: themeManager.defaultTheme == "darkTheme",
          css_width: "25%",
          value: "Dark",
          on_click: () => this.setTheme("darkTheme"),
        }),
        new ButtonComponent({
          themeId: "lightTheme",
          selectByDefault: themeManager.defaultTheme == "lightTheme",
          css_width: "25%",
          value: "Light",
          on_click: () => this.setTheme("lightTheme"),
        }),
        new ButtonComponent({
          themeId: "consoleTheme",
          selectByDefault: themeManager.defaultTheme == "consoleTheme",
          css_width: "25%",
          value: "Console",
          on_click: () => this.setTheme("consoleTheme"),
        }),
        new ButtonComponent({
          themeId: "systemTheme",
          selectByDefault: themeManager.defaultTheme == "systemTheme",
          css_width: "25%",
          value: "System",
          on_click: () => this.setTheme("systemTheme"),
        }),
      ];

      setCharset(charsetId) {
        for (let button of this.charsetButtons) {
          button.charsetId == charsetId ? button.select() : button.unselect();
        }
        charManager.setCharset(charsetId);
        layerManager.refresh(() => layerManager.renderCharset());
      }

      setTheme(themeId) {
        themeManager.setTheme(themeId);
        themeManager.renderTheme();
        for (let button of this.themeButtons) {
          button.themeId == themeId ? button.select() : button.unselect();
        }
      }

      defineChildren() {
        return [
          new Component({
            css_fontSize: "50px",
            css_width: "100%",
            css_height: "15%",
            css_textAlign: "center",
            value: "⚙",
          }),
          new Component({
            css_textAlign: "center",
            css_marginTop: "30px",
            value: "Charset",
          }),
          new Component({
            css_display: "flex",
            css_columnGap: "3px",
            css_justifyContent: "space-between",
            css_width: "100%",
            css_marginTop: "5px",
            children: this.charsetButtons,
          }),
          new Component({
            css_textAlign: "center",
            css_marginTop: "20px",
            value: "Theme",
          }),
          new Component({
            css_display: "flex",
            css_columnGap: "3px",
            css_justifyContent: "space-between",
            css_width: "100%",
            css_marginTop: "5px",
            children: this.themeButtons,
          }),
          new Component({
            css_textAlign: "center",
            css_marginTop: "20px",
            value: "Grid",
          }),
          new Component({
            css_display: "flex",
            css_justifyContent: "center",
            css_width: "100%",
            css_marginTop: "5px",
            children: [
              new ButtonComponent({
                css_width: "50%",
                on_click: () => canvas.toggleGrid(),
                value: "Toggle",
              }),
            ],
          }),
        ];
      }
    }

    class InputComponent extends Component {
      type = "input";

      css_height = "40px";
      css_border = "1px solid";
      css_borderRadius = "10px";
      css_fontFamily = "bodyFont";
      css_outline = "none";

      defineTheme() {
        this.css("backgroundColor", "buttonBgColor");
        this.css("borderColor", "buttonBorderColor");
        this.css("color", "buttonFgColor");
      }
    }

    class ButtonComponent extends Component {
      type = "button";
      css_fontFamily = "monospace";
      css_fontSize = "11px";
      css_paddingBottom = "3px";
      css_borderRadius = "10px";
      css_height = "40px";
      css_border = "1px solid";
      css_userSelect = "none";

      defineTheme() {
        this.css("backgroundColor", "buttonBgColor");
        this.css("borderColor", "buttonBorderColor");
        this.css("color", "buttonFgColor");
        this.selected ? this.select() : this.unselect();
      }

      unselect() {
        this.selected = false;
        this.css("backgroundColor", "buttonBgColor");
      }

      select() {
        this.selected = true;
        this.css("backgroundColor", "buttonSelectedBgColor");
      }

      renderCallback() {
        if (this.selectByDefault) this.select();
      }

      on_mouseDown() {
        this.css("backgroundColor", "buttonClickBgColor");
      }

      on_mouseUp() {
        this.css("backgroundColor", "buttonBgColor");
      }
    }

    class MenuButtonComponent extends ButtonComponent {
      css_border = "1px solid #212121";
      css_boxShadow = "0px 0px 20px #403f3f";
      css_marginTop = "10px";
    }

    class ModeMenuButtonComponent extends MenuButtonComponent {
      constructor(icon, name, showCondition, setModes, activeModes, callback = () => {}) {
        super();
        /*
        name: display name of the button
        showCondition: A ModeMaster condition that gets checked every Menu.refresh
          call to show/hide the button.
        setModes: A ModeMaster update command when the button is pressed.
        activeModes: A ModeMaster condition to choose if the button is selected.
        callback: A function callback on press.
        */
        this.icon = icon;
        this.name = name;
        this.isConditional = Boolean(showCondition.length);
        this.showCondition = modeMaster.makeFunc(showCondition);
        this.callback = callback;
        this.setModes = modeMaster.makeFunc(setModes);
        this.activeModesCondition = activeModes.length ? modeMaster.makeFunc(activeModes) : () => false;
      }

      on_mouseDown() {
        this.setModes();
        this.callback();
        if (!this.activeModesCondition()) super.on_mouseDown();
      }

      on_mouseUp() {
        if (!this.activeModesCondition()) super.on_mouseUp();
      }

      defineChildren() {
        return [
          new Component({
            css_display: "inline-block",
            css_fontSize: "16px",
            value: this.icon,
          }),
          new Component({
            css_display: "inline-block",
            css_marginLeft: "5px",
            value: this.name,
          }),
        ];
      }

      isActive() {
        return this.activeModesCondition();
      }

      refresh() {
        this.hide();
        this.unselect();
        if (this.showCondition()) this.show();
        if (this.isActive()) this.select();
      }
    }

    class MenuButtonLeftComponent extends ModeMenuButtonComponent {
      css_width = "100%";
    }

    class MenuComponent extends Component {
      unselectAll() {
        this.buttons.forEach(button => button.unselect());
      }

      defineChildren() {
        return this.buttons;
      }
    }

    class ModeMenuComponent extends MenuComponent {
      refresh() {
        this.buttons.forEach(button => button.refresh());
      }

      renderCallback() {
        modeMaster.registerCallback(() => this.refresh());
        this.refresh();
      }
    }

    class MainMenuComponent extends ModeMenuComponent {
      accessibleBy = "mainMenuComponent";
      css_top = "0";
      css_left = "0";
      css_right = "0";
      css_bottom = "0";
      css_display = "flex";
      css_columnGap = "3px";
      css_justifyContent = "space-between";
      css_margin = "15px auto";
      css_width = "fit-content";
      css_position = "absolute";
      css_zIndex = "100";
      css_height = "7vh";

      buttons = [
        new ModeMenuButtonComponent(
          "➤",
          "Select",
          [],
          [modeMaster.reset, "select"],
          [modeMaster.hasOr, "selected", "select"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "◻",
          "Square",
          [],
          [modeMaster.reset, "draw", "square"],
          [modeMaster.isDrawyMode, "square"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "◯",
          "Circle",
          [],
          [modeMaster.reset, "draw", "circle"],
          [modeMaster.isDrawyMode, "circle"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "t",
          "Text",
          [],
          [modeMaster.reset, "draw", "text"],
          [modeMaster.isDrawyMode, "text"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "/",
          " Line",
          [],
          [modeMaster.reset, "draw", "line", "free-line"],
          [modeMaster.isDrawyMode, "free-line"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "_|",
          "Step",
          [],
          [modeMaster.reset, "draw", "line", "step-line"],
          [modeMaster.isDrawyMode, "step-line"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "_|‾",
          "Switch",
          [],
          [modeMaster.reset, "draw", "line", "switch-line"],
          [modeMaster.isDrawyMode, "switch-line"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "◇",
          "Diamond",
          [],
          [modeMaster.reset, "draw", "diamond"],
          [modeMaster.isDrawyMode, "diamond"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "᎒᎒᎒",
          "Table",
          [],
          [modeMaster.reset, "draw", "table"],
          [modeMaster.isDrawyMode, "table"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent(
          "∿",
          "Free",
          [],
          [modeMaster.reset, "draw", "free"],
          [modeMaster.isDrawyMode, "free"],
          () => FreeLayer.startFreeDraw()
        ),
        new ModeMenuButtonComponent(
          "⌫",
          "Erase",
          [],
          [modeMaster.reset, "erase", "ebutton"],
          [modeMaster.hasOr, "erasing", "erase"],
          () => layerManager.switchModeCallback()
        ),
        new ModeMenuButtonComponent("↺", "Undo", [], [], [], event => layerManager.undoEvent(event)),
        new ModeMenuButtonComponent("↻", "Redo", [], [], [], event => layerManager.redoEvent(event)),
        new ModeMenuButtonComponent("x", "Restart", [], [], [], () =>
          layerManager.refresh(() => layerManager.emptyEvent())
        ),
        new ModeMenuButtonComponent("->", "<b>Export</b>", [], [], [], () => canvas.exportToClipboard()),
        new ModeMenuButtonComponent("$", "<b>Base64 I/O</b>", [], [], [], () =>
          bodyComponent.base64IOComponent.toggle()
        ),
        new ModeMenuButtonComponent("⚙", "<b>Settings</b>", [], [], [], () =>
          bodyComponent.settingsComponent.toggle()
        ),
        new ModeMenuButtonComponent("?", "<b>Help</b>", [], [], [], () => bodyComponent.helpComponent.toggle()),
      ];
    }

    class LeftMenuComponent extends ModeMenuComponent {
      css_height = "100vh";
      css_width = "130px";
      css_float = "left";
      css_position = "relative";
      css_zIndex = "100";
      css_marginTop = "120px";

      drawFreeOptions = [
        ["_lines", "-|", "lines"],
        ["█", "█", "fill"],
        ["x", "x", "character"],
        ["*", "*", "character"],
        [".", ".", "character"],
        ["+", "+", "character"],
        ["•", "•", "character"],
        [">", ">", "character"],
        ["<", "<", "character"],
      ];

      buttons = [
        new MenuButtonLeftComponent("⧉", "Copy", [modeMaster.has, "selected"], [], [], event =>
          layerManager.copySelectedLayersEvent(event)
        ),
        new MenuButtonLeftComponent("⧓", "Group", [modeMaster.has, "multi-select", "selected"], [], [], event =>
          layerManager.groupSelectedLayersEvent(event)
        ),
        new MenuButtonLeftComponent("⧎", "Ungroup", [modeMaster.has, "multi-select", "selected"], [], [], event =>
          layerManager.ungroupSelectedLayersEvent(event)
        ),
        new MenuButtonLeftComponent(
          "✕",
          "Delete",
          [modeMaster.has, "selected"],
          [modeMaster.reset, "select"],
          [],
          event => layerManager.deleteLayersEvent(event)
        ),
        new MenuButtonLeftComponent("⎘", "Forward", [modeMaster.has, "selected"], [], [], event =>
          layerManager.bringForwardEvent(event)
        ),
        new MenuButtonLeftComponent("⎗", "Backwards", [modeMaster.has, "selected"], [], [], event =>
          layerManager.sendBackwardsEvent(event)
        ),
        new MenuButtonLeftComponent("⎘", "Front", [modeMaster.has, "selected"], [], [], event =>
          layerManager.bringToFrontEvent(event)
        ),
        new MenuButtonLeftComponent("⎗", "Back", [modeMaster.has, "selected"], [], [], event =>
          layerManager.sendToBackEvent(event)
        ),
        new MenuButtonLeftComponent("⏴", "Arrow", [modeMaster.has, "selected", "line"], [], [], () =>
          layerManager.redrawLinesEvent("left")
        ),
        new MenuButtonLeftComponent("⏵", "Arrow", [modeMaster.has, "selected", "line"], [], [], () =>
          layerManager.redrawLinesEvent("right")
        ),
        new MenuButtonLeftComponent("⋮", "Dotted", [modeMaster.has, "selected", "line-based"], [], [], () =>
          layerManager.redrawLineBasedEvent("dotted")
        ),
        new MenuButtonLeftComponent("--", "Dashed", [modeMaster.has, "selected", "line-based"], [], [], () =>
          layerManager.redrawLineBasedEvent("dashed")
        ),
        new MenuButtonLeftComponent("―", "Solid", [modeMaster.has, "selected", "line-based"], [], [], () =>
          layerManager.redrawLineBasedEvent("solid-thin")
        ),
        new MenuButtonLeftComponent("―", "Solid bold", [modeMaster.has, "selected", "line-based"], [], [], () =>
          layerManager.redrawLineBasedEvent("solid-bold")
        ),
      ];

      drawFreeButtons() {
        let buttons = [];
        for (let [char, icon, name] of this.drawFreeOptions) {
          buttons.push(
            new MenuButtonLeftComponent(
              icon,
              name,
              [modeMaster.has, "draw", "free"],
              [modeMaster.reset, "draw", "free", "dfbutton", char],
              [modeMaster.has, char],
              event => FreeLayer.setFreeChar(char)
            )
          );
        }
        return buttons;
      }

      refresh() {
        super.refresh();
        this.hide();
        if (this.buttons.map(button => button.showCondition()).some(Boolean)) this.show();
      }

      defineChildren() {
        this.buttons = this.buttons.concat(this.drawFreeButtons());
        return super.defineChildren();
      }
    }

    class CanvasDumpComponent extends Component {
      accessibleBy = "canvasDumpComponent";

      // We never display this, but export uses this
      // to output before copying to preserve styling.
      // If a user pastes an export in the same browser,
      // the following styles can get preserved.
      // Otherwise, good luck!
      css_fontFamily = "monospace";
      css_backgroundColor = "white";
      css_color = "black";
      css_whiteSpace = "pre-wrap";
      // Hide far away (body overflow is hidden)
      css_position = "absolute";
      css_marginLeft = "500vw";
    }

    class InformerComponent extends Component {
      accessibleBy = "informerComponent";

      css_width = "30%";
      css_marginLeft = "35%";
      css_position = "absolute";
      css_marginTop = "80vh";
      css_borderRadius = "10px";
      css_boxShadow = "0px 0px 20px grey";
      css_fontSize = "15px";
      css_padding = "5px";
      css_textAlign = "center";
      css_textWeight = "bold";
      css_zIndex = "100";

      defineTheme() {
        this.css("color", "bodyFgColor");
      }

      defineChildren() {
        return [
          new Component({
            accessibleBy: "moodCharComponent",
            css_fontSize: "25px",
            type: "span",
            css_verticalAlign: "middle",
          }),
          new Component({
            accessibleBy: "messageComponent",
            css_marginLeft: "10px",
            type: "span",
            css_verticalAlign: "middle",
          }),
        ];
      }

      report(message, mood, time = null) {
        if (time == null) time = message.length * 150;
        if (time == -1) time = 100000000;
        let moodChar = "";
        switch (mood) {
          case "good":
            this.css("backgroundColor", "informerGoodBgColor");
            this.css("color", "informerGoodFgColor");
            moodChar = "✓";
            break;
          case "bad":
            this.css("backgroundColor", "informerBadBgColor");
            this.css("color", "informerBadFgColor");
            moodChar = "✕";
            break;
          default:
            this.css("backgroundColor", "informerDefaultBgColor");
            this.css("color", "informerDefaultFgColor");
        }
        this.messageComponent.setValue(message);
        this.moodCharComponent.setValue(moodChar);
        this.show();
        setTimeout(() => this.hide(), time);
      }

      loading() {
        this.report("Loading...", "", -1);
      }

      loadingFinish() {
        this.hide();
      }

      renderCallback() {
        this.hide();
      }
    }

    class Body extends Component {
      css_overflow = "hidden";

      create() {
        this.element = document.body;
      }

      assignParent(parent) {}

      defineChildren() {
        return [
          new InformerComponent(),
          new SettingsComponent(),
          new HelpComponent(),
          new MainMenuComponent(),
          new LeftMenuComponent(),
          new CanvasComponent(),
          new CanvasDumpComponent(),
          new Base64IOComponent(),
        ];
      }

      hidePopups() {
        modeMaster.setDefault();
        this.children.filter(child => child.isPopup).forEach(child => child.hide());
      }

      defineTheme() {
        this.css("backgroundColor", "bodyBgColor");
        this.css("color", "bodyFgColor");
        this.css("fontFamily", "bodyFont");
      }
    }

    function handleFirstVisit() {
      if (firstVisit) {
        let shownTip = false;
        bodyComponent.helpComponent.show();
        modeMaster.registerCallback(() => {
          if (modeMaster.has("draw") && !shownTip) {
            bodyComponent.informerComponent.report("Click and drag to start drawing in any of the draw modes!");
            shownTip = true;
          }
        });
      }
      localStorage.setItem("visited", true);
    }

    function initManagers() {
      layerManager = new LayerManager();
      modeMaster = new ModeMaster();
      areaSelectManager = new AreaSelectManager();
      eventManager = new EventManager();
      externalHookManager = new BaseExternalHookManager();
      charManager = new CharManager();
      themeManager = new ThemeManager();
    }

    function main() {
      if (isTablet()) {
        mobilePage();
        return;
      }
      initManagers();
      bodyComponent = new Body();
      bodyComponent.render();
      canvas = bodyComponent.canvasComponent;
      eventManager.assignAll({
        window: window,
        document: document,
        canvas: canvas.element,
      });
      layerManager.importFromLocalStorage();
      handleFirstVisit();
      window.dispatchEvent(new Event("casciiLoaded"));
    }

    window.onload = main; // :)
  </script>

  <!-- By design, this can happily 404 and run without a backend -->
  <script src="/static/serverLayer.js"></script>
</head>
